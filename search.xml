<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[重要基础算法]]></title>
    <url>%2F2018%2F07%2F25%2F%E9%87%8D%E8%A6%81%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Partition算法将一个数组进行划分，使左边的元素都小于某个数，右边的元素都大于等于某个数。其中最常见的就是快速排序中使用的partition算法。在面试题39,40中也有广泛应用。 实现取第一个元素为枢轴点(pivot)，使用两个指针分别从头部和尾部进行扫描，头部遇到大于pivot的数和尾部遇到小于pivot的数进行交换，一趟之后，枢轴点左边的数全部小于等于它，右边的数全部大于等于它，这样就实现了以pivot为轴的一次划分1234567891011public int partition(int[] nums, int left, int right)&#123; int pivot = nums[left]; while(left &lt; right)&#123; while(left &lt; right &amp;&amp; nums[right] &gt;= pivot) right--; nums[left] = nums[right]; while(left &lt; right &amp;&amp; nums[left] &lt;= pivot) left++; nums[right] = nums[left]; &#125; nums[left] = pivot; return left;&#125; 快速排序快速排序就就是递归的应用Partition算法，最终使整个数组实现排序1234567public void quickSort(int[] nums, int left, int right)&#123; if(left &lt; right)&#123; int index = partition(nums, left, right); 得到划分的轴点下标 quickSort(nums, left, index-1); quickSort(nums, index+1, right); &#125;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串算法题]]></title>
    <url>%2F2018%2F07%2F23%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[全排列(面试题38：字符串的全排列) 题目描述 算法思想 回溯法 交换法(拆分为子问题)求整个字符串的排列，可以看成两步。第一步求所有可能出现在第一个位置的字符(与后续字符逐个交换)，第二步固定一个字符，求后面字符的全排列。注意:递归中交换的字符要在求出一个排列后恢复原字符位置 回溯实现123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); void dfs(List&lt;Integer&gt; temp, int [] nums)&#123; if(temp.size() == nums.length)&#123; res.add(new ArrayList(temp)); return; &#125; for(int i = 0; i &lt; nums.length; i++)&#123; if(temp.contains(nums[i])) continue; temp.add(nums[i]); dfs(temp, nums); //深度优先遍历，沿当前分支继续遍历直至叶子结点 temp.remove(temp.size()-1); //当前分支遍历完后回到上个节点 &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if(nums.length == 0) return res; List&lt;Integer&gt; temp = new ArrayList(); dfs(temp, nums); return res; &#125;&#125; 交换递归实现123456789101112131415161718192021222324252627282930class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); void swap(int[] nums, int i, int j)&#123; int temp = nums[j]; nums[j] = nums[i]; nums[i] = temp; &#125; void permutation(int[] nums, int start)&#123; if(start == nums.length)&#123; List&lt;Integer&gt; temp = new ArrayList(); for(int i = 0; i &lt; nums.length; i++)&#123; temp.add(nums[i]); &#125; res.add(temp); &#125;else&#123; for(int i = start; i &lt; nums.length; i++)&#123; swap(nums, start, i); //依次交换开始字符和字符串中剩余字符 permutation(nums, start+1); //下一个字符 //恢复交换字符，a|bc =&gt; abc =&gt; b|ac =&gt; abc =&gt; c|ba(和回溯至父节点相似) swap(nums, start, i); &#125; &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123; if(nums.length == 0) return res; permutation(nums, 0); return res; &#125;&#125; 组合题目描述 算法思想DFS+回溯 回溯实现123456789101112131415161718192021class Solution &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); void dfs(List&lt;Integer&gt; list, int n, int k, int start)&#123; if(list.size() == k)&#123; res.add(new ArrayList(list)); return; &#125; //至少要保留k-len个数字(例如n=8, k=5, len=3, i&lt;=8-5+3-1=7,即至少保留7,8可供选择) for(int i = start; i &lt;= n - k + list.size() + 1; i++)&#123; //该处直接用i&lt;=n也可行，但当数据量大时会影响效率 list.add(i); dfs(list, n, k, i+1); //当前位置往后递归 list.remove(list.size()-1); &#125; &#125; public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123; List&lt;Integer&gt; list = new ArrayList(); if(n == 0) return res; dfs(list, n, k, 1); return res; &#125;&#125; 无重复字符的最长子串题目描述给定一个字符串，找出不含有重复字符的最长子串的长度。 示例：给定 “abcabcbb” ，没有重复字符的最长子串是 “abc” ，那么长度就是3。给定 “bbbbb” ，最长的子串就是 “b” ，长度是1。给定 “pwwkew” ，最长子串是 “wke” ，长度是3。请注意答案必须是一个子串，”pwke” 是 子序列 而不是子串。 算法思路遍历字符串，每循环至下一个字符，判断该字符是否包含在前面的子串中，若不在则继续遍历，若在子串中则找到重复的位置，从重复的位置后一位重新纪录 实现1234567891011121314151617class Solution &#123; public static int lengthOfLongestSubstring(String s) &#123; int start = 0, max = 0; for (int i = 0; i &lt; s.length(); i++) &#123; String temp = s.substring(start, i); String ch = String.valueOf(s.charAt(i)); //默认当前位置之前的子串都是不重复，如果当前位置之前的子串包含当前子串，则从包含的位置后面一位重新记录。 if (temp.contains(ch)) &#123; start += temp.indexOf(ch) + 1; &#125; if (i - start + 1 &gt; max) &#123; max = i - start + 1; &#125; &#125; return max; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>递归</tag>
        <tag>面试题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[栈算法题]]></title>
    <url>%2F2018%2F07%2F19%2F%E6%A0%88%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最小栈(面试题30：包含min函数的栈)题目描述设计一个支持 push，pop，top 操作，并能在常数时间内检索到最小元素的栈。push(x) – 将元素 x 推入栈中。pop() – 删除栈顶的元素。top() – 获取栈顶元素。getMin() – 检索栈中的最小元素。 示例:MinStack minStack = new MinStack();minStack.push(-2);minStack.push(0);minStack.push(-3);minStack.getMin(); –&gt; 返回 -3.minStack.pop();minStack.top(); –&gt; 返回 0.minStack.getMin(); –&gt; 返回 -2. 算法思路直观反应是在类中定义一个属性记录最小值，但问题在于如果最小值被弹出栈后，如果得到栈的次小值。所以不能仅仅只记录栈中的一个最小值，需要保存每次新元素入栈后的最小值。 辅助列表实现12345678910111213141516171819202122232425262728293031323334class MinStack &#123; List&lt;Integer&gt; minList; Stack&lt;Integer&gt; dataStack; /** initialize your data structure here. */ public MinStack() &#123; minList = new ArrayList&lt;Integer&gt;(); dataStack = new Stack&lt;Integer&gt;(); &#125; public void push(int x) &#123; dataStack.push(x); if(minList.size() == 0) minList.add(x); else if(x &lt; minList.get(minList.size()-1))&#123; minList.add(x); &#125;else minList.add(minList.get(minList.size()-1)); &#125; public void pop() &#123; if(!dataStack.empty())&#123; dataStack.pop(); minList.remove(minList.size()-1); &#125; &#125; public int top() &#123; return dataStack.peek(); &#125; public int getMin() &#123; return minList.get(minList.size()-1); &#125;&#125; 辅助栈实现123456789101112131415161718192021222324252627282930313233class MinStack &#123; Stack&lt;Integer&gt; dataStack; Stack&lt;Integer&gt; minStack; /** initialize your data structure here. */ public MinStack() &#123; dataStack = new Stack&lt;Integer&gt;(); minStack = new Stack&lt;Integer&gt;(); &#125; public void push(int x) &#123; dataStack.push(x); if(minStack.empty()) minStack.push(x); else if(x &lt; minStack.peek())&#123; minStack.push(x); &#125;else minStack.push(minStack.peek()); &#125; public void pop() &#123; if(!dataStack.empty())&#123; dataStack.pop(); minStack.pop(); &#125; &#125; public int top() &#123; return dataStack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>面试题</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树算法题]]></title>
    <url>%2F2018%2F07%2F19%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[二叉树节点定义若无特殊声明，以下所有题目二叉树节点定义都如下1234567// Definition for a binary tree node.public class TreeNode &#123; int val; TreeNode left; TreeNode right; TreeNode(int x) &#123; val = x; &#125;&#125; 另一个树的子树(面试题26：树的子结构)题目描述 算法思想遍历二叉树s，依次以每个节点为根节点，与二叉树t进行比较，看是否相同，若s中存在以某个节点为跟节点的子树与t完全相同，则返回true,否则返回false。因此需要一个判断函数和遍历函数 递归实现1234567891011121314151617class Solution &#123; // 判断两个二叉树是否相同 public boolean isSame(TreeNode t1, TreeNode t2)&#123; if(t1 == null &amp;&amp; t2 == null) return true; if(t1 == null || t2 == null) return false; if(t1.val == t2.val)&#123; return isSame(t1.left, t2.left) &amp;&amp; isSame(t1.right, t2.right); &#125; return false; &#125; // 递归调用遍历二叉树s public boolean isSubtree(TreeNode s, TreeNode t) &#123; if(s == null &amp;&amp; t == null) return true; if(s == null || t == null) return false; return isSame(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t); &#125;&#125; 剑指Offer面试题26中是判断是否存在子结构，与本题差别不大，修改下isSame函数，t2遍历完时t1还有子节点也返回true123456789public boolean isSame(TreeNode t1, TreeNode t2)&#123; if(t1 == null &amp;&amp; t2 == null) return true; if(t1 != null &amp;&amp; t2 == null) return true; if(t1 == null &amp;&amp; t2 != null) return false; if(t1.val == t2.val)&#123; return isSame(t1.left, t2.left) &amp;&amp; isSame(t1.right, t2.right); &#125; return false;&#125; 对称二叉树(面试题28：对称的二叉树)题目描述 算法思路从根节点开始遍历左右子树，判断左右节点是否相等直至遍历完成 递归实现1234567891011121314class Solution &#123; public boolean cmpChild(TreeNode left, TreeNode right)&#123; if(left == null &amp;&amp; right == null) return true; if(left == null || right == null) return false; if(left.val == right.val)&#123; return cmpChild(left.left, right.right) &amp;&amp; cmpChild(left.right, right.left); &#125; return false; &#125; public boolean isSymmetric(TreeNode root) &#123; if(root == null) return true; return cmpChild(root.left, root.right); &#125;&#125; 二叉树的层次遍历(面试题32：从上到下打印二叉树)题目描述 算法思想每层用一个列表currentLevel存放该层所有节点，然后计算以该层中的节点为根节点是否有子节点，若有子节点则获取并保存在一个新的列表nextLevel中，循环直到nextLevel中节点数为空 一般解法12345678910111213141516171819202122232425class Solution &#123; public List&lt;TreeNode&gt; nextLevel(List&lt;TreeNode&gt; currentLevel)&#123; List&lt;TreeNode&gt; next = new ArrayList(); for(int i = 0; i &lt; currentLevel.size(); i++)&#123; if(currentLevel.get(i).left != null) next.add(currentLevel.get(i).left); if(currentLevel.get(i).right != null) next.add(currentLevel.get(i).right); &#125; return next; &#125; public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); if(root == null) return res; List&lt;TreeNode&gt; next = new ArrayList(); next.add(root); while(next.size() != 0)&#123; List&lt;Integer&gt; temp = new ArrayList(); for(TreeNode each : next) temp.add(each.val); res.add(temp); next = nextLevel(next); &#125; return res; &#125;&#125; 剑指Offer上采用队列作容器因为每一层都是从左至右顺序打印，先进入的节点先打印，打印后它的左右孩子再顺序入队，符合先入先出原则，所以可以采用队列来解决 二叉树锯齿形层次遍历(面试题32变种：之字形打印二叉树)题目描述 算法思想和上一题二叉树的层次遍历相似，只不过不是一直从左至右的顺序打印。在奇数层是从左至右打印，偶数层是从右至左，所以我们用一个变量levelNum来记录当前二叉树遍历的层数。 一般实现1234567891011121314151617181920212223242526272829303132333435class Solution &#123; public List&lt;TreeNode&gt; nextLevel(List&lt;TreeNode&gt; currentLevel, int levelNum)&#123; List&lt;TreeNode&gt; next = new ArrayList(); if((levelNum+1) % 2 != 0)&#123; // 每层List首尾相连，倒序取得子节点 for(int i = currentLevel.size()-1; i &gt;= 0; i--)&#123; if(currentLevel.get(i).left != null) next.add(currentLevel.get(i).left); if(currentLevel.get(i).right != null) next.add(currentLevel.get(i).right); &#125; &#125;else&#123; for(int i = currentLevel.size()-1; i &gt;= 0; i--)&#123; if(currentLevel.get(i).right != null) next.add(currentLevel.get(i).right); if(currentLevel.get(i).left != null) next.add(currentLevel.get(i).left); &#125; &#125; return next; &#125; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123; if(root == null) return res; List&lt;TreeNode&gt; next = new ArrayList(); next.add(root); int level = 1; while(next.size() != 0)&#123; List&lt;Integer&gt; temp = new ArrayList(); for(TreeNode each : next) temp.add(each.val); res.add(temp); next = nextLevel(next, level); level++; &#125; return res; &#125;&#125; 路径总和(面试题34：二叉树中和为某一值的路径)题目描述 算法思路DFS + 回溯 回溯实现12345678910111213141516171819202122232425262728class Solution &#123; public void dfs(List&lt;Integer&gt; list, TreeNode root, int sum)&#123; list.add(root.val); if(root.left == null &amp;&amp; root.right == null)&#123; int temp = 0; for(int i = 0; i &lt; list.size(); i++)&#123; temp += list.get(i); //累加节点和 &#125; if(temp == sum) lists.add(new ArrayList(list)); //相等加入可以路径 &#125; if(root.left != null)&#123; //不到叶节点一直往下遍历 dfs(list, root.left, sum); list.remove(list.size()-1); //回到上层父节点 &#125; if(root.right != null)&#123; dfs(list, root.right, sum); list.remove(list.size()-1); &#125; &#125; List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList(); public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123; if(root == null) return lists; List&lt;Integer&gt; list = new ArrayList(); dfs(list, root, sum); return lists; &#125;&#125; 二叉树展开为链表题目描述 算法思路使用递归的思想，首先使用DFS思路找到左子树的最左节点，然后将该最左节点的父节点和右子树断开，把该最左节点连接到父节点的右节点上，左节点置为null，再把原右子树连接到原左子树的最右节点上，再往上遍历 后序遍历实现(中序也可)12345678910111213class Solution &#123; public void flatten(TreeNode root) &#123; if(root == null) return; flatten(root.left); //找到最左叶子节点 flatten(root.right); TreeNode temp = root.right; //记录右子树 root.right = root.left; //断开右子树，把左子树作为根节点右孩子 root.left = null; //左子树置空 while(root.right != null) root = root.right; //找到移接后的右叶子节点 root.right = temp; //接上原右子树 &#125;&#125; 二叉树的序列化与反序列化(面试题37：序列化二叉树)题目描述 算法思路遍历二叉树，孩子节点为空的序列化为字符保存(如’$’)，节点之间用空格来分隔。可采用前序遍历、层次遍历来序列化，如上图可序列化如下： 前序遍历 [1,2,$,$,3,4,5] 层次遍历 [1,2,3,$,$,4,5] 前序遍历实现1234567891011121314151617181920212223242526272829public class Codec &#123; // Encodes a tree to a single string. public String serialize(TreeNode root) &#123; String str = new String(); if(root == null) return "$" + " "; str += String.valueOf(root.val) + " "; str += serialize(root.left); str += serialize(root.right); return str; &#125; // Decodes your encoded data to tree. int index = -1; public TreeNode deserialize(String data) &#123; String[] res = data.split(" "); return dfs(res); &#125; public TreeNode dfs(String[] res)&#123; index++; TreeNode node = null; //每个节点初始默认为空 if(!res[index].equals("$"))&#123; //如果序列化中的记录不为空 node = new TreeNode(Integer.valueOf(res[index])); //实例化该节点 node.left = dfs(res); //递归重建左子树 node.right = dfs(res); //递归重建右子树 &#125; return node; //返回最外层递归第一个节点(即根节点) &#125;&#125; 层次遍历较为复杂，由于节点先进先出特性可采用队列来存储每层节点，完成序列化]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WPF USB-HID项目]]></title>
    <url>%2F2018%2F07%2F19%2FWPF%20USB-HID%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[记录部分项目中遇到的问题和解决方案——项目GitHub链接 项目上传GitHub 安装Git,进入项目目录，点击“Git Bash Here”，打开git命令行 输入“git init”，将项目文件夹加入git管理 输入“git add .”（不要漏了“.”），将文件夹全部内容添加到git。 输入“git commit -m “first commit””（“git commit -m “提交信息””） 输入“git remote add origin https://github.com/ResultLv/SuzhouClient”（git remote add origin 你自己的https地址），连接你的guthub仓库。 输入“git push -u origin master”，上传项目到Github。这里会要求输入Github的账号密码，按要求输入就可以。 USB单例模式USB-HID设备在连接后只能由当前实例的输入输出流执行写入读出操作，在多个页面实例化USB对象后写入命令无效。想到的可行的解决办法是全局只实例化一个对象，因此可以采用单例模式 USB类中定义单例12345678910111213141516171819202122232425// 定义一个静态变量来保存类的实例private static USBHID uniqueInstance;// 定义一个标识确保线程同步private static readonly object locker = new object();public static USBHID GetInstance()&#123; // 当第一个线程运行到这里时，此时会对locker对象 "加锁"， // 当第二个线程运行该方法时，首先检测到locker对象为"加锁"状态，该线程就会挂起等待第一个线程解锁 // lock语句运行完之后（即线程运行完之后）会对该对象"解锁" // 双重锁定只需要一句判断就可以了 if (uniqueInstance == null) &#123; lock (locker) &#123; // 如果类的实例不存在则创建，否则直接返回 if (uniqueInstance == null) &#123; uniqueInstance = new USBHID(); &#125; &#125; &#125; return uniqueInstance;&#125; VeiwModel中获取实例12// 获取USB唯一实例public static USBHID usbHID = USBHID.GetInstance(); MVVM模式下登录窗体关闭MVVM模式下界面和逻辑分离，在登录成功后我们需要关闭弹出的登录界面，而在ViewModel中又不能直接关闭窗口，该怎么实现这个功能呢？控件有个IsEnabled属性，可以禁用启用控件。我们可以在ViewModel中绑定IsEnabled属性，登录成功后修改这个属性的值为false，后台写一个IsEnabledChanged事件来捕获值的改变，发生改变时关闭该窗口即可。 MVVM模式下登录成功跳转View登录按钮绑定signin命令，且附带grid控件作为参数，frame控件实现登录成功后的跳转 绑定的打开登录窗口命令12345678910111213141516171819202122232425262728public ICommand signin // 打开登录页面&#123; get &#123; return new DelegateCommand&lt;Grid&gt;((grid) =&gt; //使用Prism框架实现的DelegateCommand类 &#123; if (USBHID.isOpened) &#123; // 登录前先判断用户名是否已设置(发送中断命令给USB设备) int isSet = int.Parse(getReturn("04 00").Substring(5, 1)); // 已设置则跳转至登录界面 if (isSet == 0) &#123; hasSet(grid); &#125; else &#123; MessageBox.Show("该设备还未设置过账号，请设置用户名和密码"); user setUser = new user(); setUser.ShowDialog(); &#125; &#125; else MessageBox.Show("USB未插入或已变为外存"); &#125;); &#125;&#125; 这个地方将grid作为参数传入是为了通过grid.chilren获取子控件修改界面，获取到farme控件实现登录后的跳转 调用的hasSet函数实现跳转和修改主界面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public void hasSet(Grid grid)&#123; DockPanel loginPanel = null; Frame mainFrame = null; for (int i = 0; i &lt; grid.Children.Count; i++) &#123; if (grid.Children[i] is DockPanel) &#123; loginPanel = (DockPanel)grid.Children[i]; // 获取登录按钮所在panel &#125; if(grid.Children[i] is Frame) &#123; mainFrame = (Frame)grid.Children[i]; // 获取frame控件 &#125; &#125; login log = new login(); log.ShowDialog(); if (log.hasLogin == true) //如果登录成功，则在主界面修改View &#123; loginSuccess = true; string UserName = log.userName; loginPanel.Children.Clear(); TextBlock txBlock = new TextBlock(); txBlock.Text = UserName + "，欢迎您！"; txBlock.FontSize = 14; txBlock.Margin = new Thickness(0, 0, 10, 0); txBlock.HorizontalAlignment = System.Windows.HorizontalAlignment.Right; txBlock.VerticalAlignment = System.Windows.VerticalAlignment.Center; Button btn = new Button(); btn.Content = "退出登录"; btn.FontSize = 14; btn.Width = 70; btn.Height = 20; btn.Margin = new Thickness(0, 0, 10, 0); DockPanel.SetDock(btn, Dock.Right); btn.Command = exitLogin; btn.CommandParameter = grid; loginPanel.Children.Add(btn); loginPanel.Children.Add(txBlock); try &#123; //登录成功实现跳转 Thread.Sleep(1400); mainFrame.Navigate(new Uri("/View/display.xaml", UriKind.Relative)); &#125; catch (System.NullReferenceException) &#123; MessageBox.Show(mainFrame.ToString()); &#125; &#125;&#125; DataList数据绑定ViewItemSource绑定数据源datalist, DataGridTextColumn依次绑定各个属性, 显示效果如下图所示 ObservableCollection使用123456789101112131415161718ObservableCollection&lt;Data&gt; _datalist = new ObservableCollection&lt;Data&gt;();public ObservableCollection&lt;Data&gt; datalist&#123; set &#123; _datalist = value; RaisePropertyChanged("datalist"); &#125; get &#123; return datalistHandle(_datalist); &#125;&#125;public ObservableCollection&lt;Data&gt; datalistHandle(ObservableCollection&lt;Data&gt; _datalist)&#123; int len = _datalist.Count; for (int i = 0; i &lt; len; i++) &#123; if (_datalist[i].Dis.Equals("1")) _datalist[i].Dis = "未拆除"; if (_datalist[i].Dis.Equals("0")) _datalist[i].Dis = "已拆除"; &#125; return _datalist;&#125; datalist赋值1234567891011121314151617// 读取所有数据public ICommand readAll&#123; get &#123; return new DelegateCommand(() =&gt; &#123; datalist.Clear(); List&lt;List&lt;string&gt;&gt; dataRead = read(); for (int i = 0; i &lt; dataRead.Count; i++) &#123; datalist.Add(new Data(int.Parse(dataRead[i][0]), dataRead[i][1], int.Parse(dataRead[i][2]), dataRead[i][3], dataRead[i][4], dataRead[i][5], dataRead[i][6], int.Parse(dataRead[i][7]), int.Parse(dataRead[i][8]), dataRead[i][9])); &#125; &#125;); &#125;&#125;]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>WPF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题25：合并排序链表]]></title>
    <url>%2F2018%2F07%2F09%2F%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[合并两个排序链表题目描述将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。示例：输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 循环解法12345678910111213141516171819202122232425262728293031323334353637383940class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null) return l2; if(l2 == null) return l1; ListNode head,p; if(l1.val &lt;= l2.val)&#123; head = l1; l1 = l1.next; &#125;else&#123; head = l2; l2 = l2.next; &#125; p = head; while(l1 != null &amp;&amp; l2 != null)&#123; if(l1.val &lt;= l2.val)&#123; p.next = l1; l1 = l1.next; &#125;else&#123; p.next = l2; l2 = l2.next; &#125; p = p.next; &#125; if(l1 == null)&#123; while(l2 != null)&#123; p.next = l2; p = p.next; l2 = l2.next; &#125; &#125; if(l2 == null)&#123; while(l1 != null)&#123; p.next = l1; p = p.next; l1 = l1.next; &#125; &#125; return head; &#125;&#125; 递归解法123456789101112131415class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1 == null) return l2; if(l2 == null) return l1; ListNode head = null; //每次递归的下个节点 if(l1.val &lt; l2.val)&#123; head = l1;; head.next = mergeTwoLists(l1.next, l2); //当前节点与下个节点连接 &#125;else&#123; head = l2; head.next = mergeTwoLists(l1, l2.next); &#125; return head; &#125;&#125; 合并k个排序链表题目描述合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。示例:输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 依次两两合并(时间复杂度较高)123456789public ListNode mergeKLists(ListNode[] lists) &#123; if(lists.length == 0) return null; if(lists.length == 1) return lists[0]; ListNode result = null; for(int i = 0; i &lt; lists.length; i++)&#123; result = mergeTwoLists(result, lists[i]); &#125; return result;&#125; 原地合并12345678910111213public ListNode mergeKLists(ListNode[] lists) &#123; if(lists.length == 0) return null; if(lists.length == 1) return lists[0]; int begin = 0, end = lists.length-1; while(end &gt; 0)&#123; begin = 0; while(begin &lt; end)&#123; // 首尾两两合并后新链表放首位置 lists[begin] = mergeTwoLists(lists[begin], lists[end]); begin++; end--; &#125; &#125; return lists[0]; //lists[0]中即为全部合并结束后的最终链表&#125; 分治合并1234567891011121314public ListNode partition(ListNode[] lists, int start, int end)&#123; if (start == end) return lists[start]; if(start &lt; end) &#123; ListNode l1 = partition(lists, start, (start + end) / 2); ListNode l2 = partition(lists, (start + end) / 2 + 1, end); return mergeTwoLists(l1, l2); //对半划分直至单个链表，再自底向上两两合并 &#125; return null;&#125;public ListNode mergeKLists(ListNode[] lists) &#123; if(lists.length == 0) return null; if(lists.length == 1) return lists[0]; return partition(lists, 0, lists.length-1);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>面试题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WPF MVVV模式实现]]></title>
    <url>%2F2018%2F07%2F05%2FWPF%20MVVV%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[两篇好文MVVM模式解析和在WPF中的实现MVVM中轻松实现Command绑定 MVVM介绍MVVM是Model-View-ViewModel（模型-视图-视图模型）的缩写形式，它通常被用于WPF或Silverlight开发。它充分利用了WPF的数据绑定和命令绑定机制，最大限度地降低了Xmal文件和CS文件的耦合度，也就是UI显示和逻辑代码的耦合度，如需要更换界面时，逻辑代码修改很少，甚至不用修改。与WinForm开发相比，我们一般在后置代码中会使用控件的名字来操作控件的属性来更新UI，而在WPF中通常是通过数据绑定来更新UI；在响应用户操作上，WinForm是通过控件的事件来处理，而WPF可以使用命令绑定的方式来处理，耦合度将降低。 View就是用xaml实现的界面，负责与用户交互，接收用户输入，把数据展现给用户。 ViewModel是一个C#类，负责收集需要绑定的数据和命令，聚合Model对象，通过View类的DataContext属性绑定到View，同时也可以处理一些UI逻辑。 Model，就是系统中的对象，可包含属性和行为。 WPF中MVVM的解耦方式如上图所示，WPF应用程序所涉及到的无非就是界面+逻辑，也就是.xaml和.cs。逻辑负责执行界面响应和数据处理，而界面就是负责展示数据，WPF的数据绑定和命令绑定可以很好的支持MVVM模式的实现。界面响应即对应命令绑定，数据展示即对应数据绑定在WPF的MVVM模式中，View和ViewModel之间数据和命令的关联都是通过绑定实现的，绑定后View和ViewModel并不产生直接的依赖。具体就是View中出现数据变化时会尝试修改绑定的目标。同样View执行命令时也会去寻找绑定的Command并执行。反过来，ViewModel在Property发生改变时会发个通知说“名字叫XXX的Property改变了，你们这些View中谁绑定了XXX也要跟着变啊!”，至于有没有View收到是不是做出变化也不关心。ViewModel中的Command脱离View就更简单了，因为Command在执行操作过程中操作数据时，根本不需要操作View中的数据，只需要操作ViewModel中的Property就可以了，Property的变化通过绑定就可以反映到View上。这样在测试Command时也不需要View的参与。这也是我在接触WPF初期时根本理解不了的所谓数据驱动。 数据绑定Model Model文件夹新建用户和设备类12345678910111213141516class UserInfo //用户类&#123; string userName; string passWord; public string UserName &#123; get =&gt; userName; set =&gt; userName = value; &#125; public string PassWord &#123; get =&gt; passWord; set =&gt; passWord = value; &#125;&#125;class DeviceInfo //设备类&#123; string vID; string pID; public string VID &#123; get =&gt; vID; set =&gt; vID = value; &#125; public string PID &#123; get =&gt; pID; set =&gt; pID = value; &#125;&#125; ViewModel ViewModel文件夹新建DeviceInfoVM类，实现INotifyPropertyChanged接口，并声明用户和设备类实例12345678910111213141516171819202122232425262728293031class DeviceInfoVM: INotifyPropertyChanged // 实现INotifyPropertyChanged接口，通知界面更新&#123; DeviceInfo devInfo; UserInfo userInfo; public DeviceInfoVM() &#123; devInfo = new DeviceInfo(); userInfo = new UserInfo(); &#125; public string VID &#123; set &#123; devInfo.VID = value; RaisePropertyChanged("VID"); &#125; //收到通知触发属性改变 get &#123; return devInfo.VID;&#125; &#125; public string PID &#123; set &#123; devInfo.PID = value; RaisePropertyChanged("PID"); &#125; get &#123; return devInfo.PID; &#125; &#125; public string UserName &#123; set &#123; userInfo.UserName = value; RaisePropertyChanged("UserName"); &#125; get &#123; return userInfo.UserName; &#125; &#125; public string PassWord &#123; set &#123; userInfo.PassWord = value; RaisePropertyChanged("PassWord"); &#125; get &#123; return userInfo.PassWord; &#125; &#125;&#125; ViewModel类实现INotifyPropertyChanged的接口。任何实现了这个接口的类，当属性发生改变的时候会通知所有监听者，视图中所有绑定了的属性都会相应改变 注册PropertyChanged事件，和实现RaisePropertyChanged方法123456789101112// 注册属性改变事件(PropertyChanged)public event PropertyChangedEventHandler PropertyChanged;// 处理属性改变的方法public void RaisePropertyChanged(string propertyName)&#123; PropertyChangedEventHandler handler = PropertyChanged; if(handler != null) //若捕获到属性改变的事件则改变相应名称名称的属性 &#123; handler(this, new PropertyChangedEventArgs(propertyName)); &#125;&#125; View 引用源声明ViewModel实例 1234 &lt;Window.DataContext&gt;// 在引用源中声明创建一个DeviceInfoVM的实例 &lt;local:DeviceInfoVM&gt;&lt;/local:DeviceInfoVM&gt; &lt;/Window.DataContext&gt; 绑定属性 123456789101112&lt;StackPanel&gt; &lt;DockPanel Margin="10"&gt; &lt;TextBlock&gt;VID&lt;/TextBlock&gt; &lt;TextBox Text="&#123;Binding VID&#125;"&gt;&lt;/TextBox&gt; &lt;Button Width="80"&gt;连接设备&lt;/Button&gt; &lt;/DockPanel&gt; &lt;DockPanel Margin="10,0,10,10"&gt; &lt;TextBlock&gt;PID&lt;/TextBlock&gt; &lt;TextBox Text="&#123;Binding PID&#125;"&gt;&lt;/TextBox&gt; &lt;Button Width="80"&gt;断开连接&lt;/Button&gt; &lt;/DockPanel&gt;&lt;/StackPanel&gt; 修改视图MainWindow.xaml.cs文件 123456789public partial class MainWindow : Window&#123; DeviceInfoVM devInfoVM; //声明ViewModle对象 public MainWindow() &#123; InitializeComponent(); devInfoVM = base.DataContext as DeviceInfoVM; // 将DeviceInfoVM对象作为数据上下文 &#125;&#125; 此时当ViewModel中收到属性改变通知时就会更新视图，同步数据 命令绑定命令绑定要关注的核心就是两个方面的问题，命令能否执行和命令怎么执行。比如当View中的一个Button绑定了ViewModel中一个命令后，什么时候这个Button是可用的，按下Button后执行什么操作。解决了这两个问题基本就实现了命令绑定。另外一个问题就是执行过程中需要的数据（参数）要如何传递。 命令绑定实现绑定命令需要实现ICommand接口，该接口包含：12345public event EventHandler CanExecuteChanged // 在命令可执行状态发生改变时触发public bool CanExecute(object parameter) //检查命令是否可用的方法public void Execute(object parameter) //命令执行的方法 流程总结如下图： 自定义命令绑定如果自定义被绑定的命令话，实现以上三个接口如下图所示：CanExecute和Execute方法是接口给出的，我们要做的就是新建一个类MyCommand来实现这两个方法执行的内容。可以通过在MyCommand的构造函数中传入Action和Func&lt;object,bool&gt;，让CanExecute执行Func&lt;object,bool&gt;，Execute执行Action。实现后MyCommand结构如下图所示，其中浅绿色背景的为ICommand接口的实现，浅蓝色背景的为MyCommand的成员 Prism框架实现(DelegateCommand)简单起见可直接使用框架中已实现好的ICommand类，此处采用Prism的委托命令DelegateCommand 项目中添加Prism.dll引用，也可直接在NuGet中安装Prism WPF框架 在ViewModel中定义ICommand命令和委托方法，注意DelegateCommand是Prism中的类(已实现好了ICommand命令，可直接调用实例)1234567891011121314151617public ICommand loginClick //绑定登录按钮点击命令&#123; get &#123; return new DelegateCommand&lt;PasswordBox&gt;((passwordBox) =&gt; //传递passwordBox参数 &#123; if (this.UserName == "123" &amp;&amp; passwordBox.Password == "123") &#123; MessageBox.Show("连接成功"); this.VID = "lrz"; //触发命令改变属性 this.PID = "666"; MessageBox.Show(this.VID); &#125; else MessageBox.Show("用户名或密码不正确"); &#125;); &#125;&#125; DelegateCommand可传递参数，绑定命令同时绑定元素名可传递元素参数。上段代码中因为安全性问题，密码框不是依赖属性，无法进行属性绑定，但在命令绑定时密码框中的内容可作为命令参数传入，因而可以避免在.cs进行逻辑判断，实现在ViewModel中处理登录逻辑，做到了View和Model解耦 xaml中绑定，然后在Button的Command中指定绑定loginClick命令12345&lt;DockPanel Margin="10"&gt; &lt;TextBlock Name="uname"&gt;用户名&lt;/TextBlock&gt; &lt;TextBox Text="&#123;Binding UserName&#125;"&gt;&lt;/TextBox&gt; &lt;Button Width="60" Command="&#123;Binding loginClick&#125;" CommandParameter="&#123;Binding ElementName=passwordBox&#125;"&gt;登录&lt;/Button&gt;&lt;/DockPanel&gt; 登录成功后，则能读取设备的VID和PID等信息，然后通知属性改变，View通过数据绑定更新数据 事件绑定WPF中不是所有的控件都有Command属性的，如果窗体我需要在ViewModel中处理Loaded事件命令，或者其他事件的命令时，很难都过绑定Command完成，必须要进行依赖注入注册依赖属性或事件。对于规模不大的项目而言，依赖注入过于繁琐，因而以下采取一种较为简单的方式实现事件绑定 例如要处理Button的MouseMove事件，但又避免用后置代码，尽量在ViewModel中处理事件。此时可以通过事件触发器来引发MouseMove事件。除了前文命令绑定提到的Prism.dll，还需要引用System.Windows.Interactivity.dll，该dll在安装Blend后添加引用即可。 xaml代码 12345678910// 添加引用xmlns:i="clr-namespace:System.Windows.Interactivity;assembly=System.Windows.Interactivity"&lt;Button&gt; &lt;i:Interaction.Triggers&gt; &lt;i:EventTrigger EventName="MouseMove"&gt; &lt;i:InvokeCommandAction Command="&#123;Binding MouseMove&#125;" /&gt; &lt;/i:EventTrigger&gt; &lt;/i:Interaction.Triggers&gt;&lt;/Button&gt; ViewModel代码 12345678910public ICommand MouseMove&#123; get &#123; return new DelegateCommand(() =&gt; &#123; MessageBox.Show("鼠标移出按钮了!") &#125;); &#125;&#125; 示例截图]]></content>
      <categories>
        <category>WPF</category>
      </categories>
      <tags>
        <tag>WPF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题23：链表中环的入口节点]]></title>
    <url>%2F2018%2F07%2F04%2F%E9%9D%A2%E8%AF%95%E9%A2%9823%EF%BC%9A%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[题目描述给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。 说明：不允许修改给定的链表。进阶：你是否可以不用额外空间解决此题？ 思路首先是判断链表中是否有环，然后再找到环的入口 判断是否有环。可以用一快一满两个指针，快指针每次走两步，慢指针每次走一步。如果快指针追上了慢指针，则链表中有环 找到环的入口。假定环的长度为n，链表长度为len，让p1,p2两个指针开始都指向头节点，p1先走n步，此时p1距尾结点还剩len-n-1步。p1走len-n步后即到达环入口，p2同时走len-n步后也会达到入口。所以当p1,p2相遇时的节点就是环的入口 确定环的长度。第一步中判断有环，快慢两个指针相遇时，相遇节点必定在环中。此时慢指针继续向前移动，并累计节点个数，当回到相遇节点时，计数即为环的长度。 双指针法判断是否有环并确定环的长度1234567891011121314151617public int cycleLen(ListNode head)&#123; if(head == null) return 0; ListNode p1 = head, p2 = head; while(p2 != null &amp;&amp; p2.next != null)&#123; p1 = p1.next; p2 = p2.next.next; if(p1 == p2)&#123; int count = 1; while(p1 != p2.next)&#123; count++; p2 = p2.next; &#125; return count; &#125; &#125; return 0;&#125; 找到环的入口1234567891011public ListNode detectCycle(ListNode head) &#123; int n = cycleLen(head); if(n == 0) return null; ListNode p1 = head, p2 = head; for(int i = 0; i &lt; n; i++) p1 = p1.next; while(p1 != p2)&#123; p1 = p1.next; p2 = p2.next; &#125; return p1;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>面试题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表算法题]]></title>
    <url>%2F2018%2F06%2F28%2F%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[单链表123456// 单链表节点定义public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 删除链表中的节点删除链表中等于给定值 val 的所有节点。 示例:输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6输出: 1-&gt;2-&gt;3-&gt;4-&gt;5 注意：该题中头节点也可存值1234567891011121314151617181920// 常规解法class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; while(head != null &amp;&amp; head.val == val)&#123; // 找到第一个值不为val的节点作为头结点 head = head.next; &#125; if(head == null) return null; ListNode q = head, p = head.next; while(p != null)&#123; if(p.val == val)&#123; q.next = p.next; p = q.next; &#125;else&#123; q = p; p = p.next; &#125; &#125; return head; &#125;&#125; 12345678// 大佬解法class Solution &#123; public ListNode removeElements(ListNode head, int val) &#123; if (head == null) return null; head.next = removeElements(head.next, val); // 删除后的连接操作 return head.val == val ? head.next : head; // 当前递归层head节点的下一个指向上一层递归返回节点 &#125;&#125; 删除链表中的节点2请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 示例 1:输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9. 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 可以把要删除的节点，用该节点的后面节点进行覆盖，然后删掉后面那个节点123456class Solution &#123; public void deleteNode(ListNode node) &#123; node.val = node.next.val; node.next = node.next.next; &#125;&#125; 删除链表中倒数第n个节点给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例：给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.说明：给定的 n 保证是有效的。 一趟扫描实现用空间换时间,用一个List存储链表中遍历的所有节点，找到倒数第n个节点并删除123456789101112131415class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; if(head == null || head.next == null) return null; List&lt;ListNode&gt; list = new ArrayList(); while(head != null)&#123; list.add(head); head = head.next; &#125; int len = list.size(); if(n == len) return list.get(1); // 删除第一个节点 if(n == 1) list.get(len-2).next = null; //删除最后一个节点 else list.get(len-n-1).next = list.get(len-n+1); // 删除中间节点 return list.get(0); &#125;&#125; 双指针法因为是删除倒数第n个节点，假设链表长度为len，那么就是正数第len-n+1个节点，删除要找到要删除节点的前一个，即第len-n个节点。设置两个指针i,j i先走n步，然后j再从头结点出发，从第n步开始i,j同时移动直到i到达尾结点,此时j移动步数为len-n,即找到了要删除的节点的前驱节点123456789101112131415161718class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode i, j; i = j = head; for(int index = 0; index &lt; n; index++) i = i.next; if(i == null)&#123; head = head.next; return head; &#125; while(i.next != null)&#123; j = j.next; i = i.next; &#125; j.next = j.next.next; return head; &#125;&#125; 反转链表示例:输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 我的解法(需额外节点长度存储空间)12345678910111213141516class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head == null) return null; List&lt;ListNode&gt; list = new ArrayList(); while(head != null)&#123; list.add(head); head = head.next; &#125; int len = list.size(); for(int i = 1; i &lt; len; i++)&#123; list.get(len-i).next = list.get(len-i-1); &#125; list.get(0).next = null; return list.get(len-1); &#125;&#125; 常规迭代解法(头插法)12345678910111213class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head == null) return null; ListNode tail = null; while(head != null)&#123; ListNode nextNode = head.next; // 保留下个节点 head.next = tail; // 当前节点指向反转后链表 tail = head; // 反转链表头结点替换为当前节点 head = nextNode; // 转到下个节点 &#125; return tail; &#125;&#125; 头插法图解 递归解法123456789class Solution &#123; public ListNode reverseList(ListNode head) &#123; if(head == null||head.next == null) return head; // 递归出口，当前为最后一个节点 ListNode tail = reverseList(head.next); // 反转后的头结点 head.next.next = head; //反向连接(当前节点的下个节点指向当前节点) head.next = null; // 断开正向连接 return tail; &#125;&#125; 图解如下： 复制带随机指针的链表（面试题35： 复杂链表的复制）题目描述给定一个链表，每个节点包含一个额外增加的随机指针，该指针可以指向链表中的任何节点或空节点。要求返回这个链表的深度拷贝。 算法思路 和一般的链表不同的是每个节点还加入了随机指针S，直接复制后，需要对每个复制节点都在原链表中找到其随机指向S，因此总的时间复杂度为$O(n_2)$ 尝试优化查找随机指向的时间效率，可以采用Hash表来存储原链表N和复制链表N’的对应关系&lt;N, N’&gt;。用空间换时间，时间复杂度$O(n)$，空间复杂度$O(n)$ 不用辅助空间 如果把复制链表N’的每个节点连接在原链表N的后面，这样就不需要额外的空间来存储对应关系了。我们需要做的是先将每个节点复制在N对应节点后面，再连接随机指针，最后拆分成两个链表。时间复杂度$O(n)$，空间复杂度$O(1)$ Hash表实现1234567891011121314151617181920public class Solution &#123; //Hash表实现 public RandomListNode copyRandomList(RandomListNode head) &#123; if(head == null) return null; RandomListNode copyHead = new RandomListNode(head.label); RandomListNode p = copyHead; Map&lt;RandomListNode, RandomListNode&gt; map = new HashMap(); map.put(head, copyHead); while(head.next != null)&#123; p.next = new RandomListNode(head.next.label); map.put(head.next, p.next); //保存复制链表和原链表的节点对应关系 p = p.next; head = head.next; &#125; for(Map.Entry&lt;RandomListNode, RandomListNode&gt; each : map.entrySet()) &#123; each.getValue().random = map.get(each.getKey().random); &#125; return copyHead; &#125;&#125; 最优效率实现Tipsjava中方法参数传递方式本质都是按值传递。 如果参数是基本类型，传递的是基本类型的字面量值的拷贝。 如果参数是引用类型，传递的是该参量所引用的对象在堆中地址值的拷贝。123456789101112131415161718192021222324252627282930313233343536373839404142//克隆节点public static void cloneNodes(RandomListNode head)&#123; while(head != null)&#123; RandomListNode clone = new RandomListNode(head.label); RandomListNode next = head.next; head.next = clone; clone.next = next; head = next; // head指向了下一个节点 &#125;&#125;//随机指针连接public static void connectRandomNodes(RandomListNode head)&#123; while(head != null) &#123; if(head.random != null) head.next.random = head.random.next; else head.next.random = null; head = head.next.next; &#125;&#125;//链表拆分，返回复制链表public static RandomListNode splitNodes(RandomListNode head) &#123; RandomListNode copyHead = head.next; RandomListNode p = copyHead; while(p.next != null) &#123; head.next = p.next; head = head.next; p.next = head.next; p = p.next; if(p.next == null)&#123; //原链表已到达最后一个节点,断开与下一个克隆节点的连接，手动置空 head.next = null; &#125; &#125; return copyHead;&#125;public RandomListNode copyRandomList(RandomListNode head) &#123; if(head == null) return null; //若原链表为空，则返回空 cloneNodes(head); connectRandomNodes(head); return splitNodes(head);&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>面试题</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题19：正则表达式匹配]]></title>
    <url>%2F2018%2F06%2F28%2F%E9%9D%A2%E8%AF%95%E9%A2%9819%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[题目描述给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*‘ 的正则表达式匹配。 ‘.’ 匹配任意单个字符。 ‘*’ 匹配零个或多个前面的元素。 匹配应该覆盖整个字符串 (s) ，而不是部分字符串。 说明:s 可能为空，且只包含从 a-z 的小写字母。p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。 示例 1:输入:s = “aaa”p = “a*“输出: true解释: “*“ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 两次, 字符串可变为 “aaa”。 示例 2:输入:s = “abcd”p = “.*“输出: true解释: “.*“ 表示可匹配零个或多个(‘*‘)任意字符(‘.’)。 示例 3:输入:s = “aab”p = “c*a*b”输出: true解释: ‘c’ 可以不被匹配, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。 示例 5:输入:s = “mississippi”p = “mis*is*p*.”输出: false 递归解法(常规版)给字符串和pattern各自设置下标，分两种情况进行匹配，一种是pattern的下一个字符为星号，一种是不为星号,同时考虑为空的边界情况。1234567891011121314151617181920212223class Solution &#123; public boolean match(String s, String p, int i, int j)&#123; if(i == s.length() &amp;&amp; j == p.length()) return true; if(i != s.length() &amp;&amp; j == p.length()) return false; if(j + 1 &lt; p.length() &amp;&amp; p.charAt(j+1) == '*')&#123; //如果模式串下个字符为* if(i == s.length()) return match(s, p, i, j+2); // 字符串匹配到最后一位，结束当前模式字符* if(s.charAt(i) == p.charAt(j) || p.charAt(j) == '.')&#123; return match(s, p, i+1, j) || match(s, p, i, j+2); // 匹配下一个字符或者抛弃这个星号去匹配下一个模式 &#125; return match(s, p, i, j+2); //直接放弃当前*号 &#125; if(i == s.length() &amp;&amp; j != p.length()) return false; if(s.charAt(i) == p.charAt(j) || p.charAt(j) == '.')&#123; //字符串单个字符与模式串单个字符或.匹配 return match(s, p, i+1, j+1); &#125; return false; &#125; public boolean isMatch(String s, String p) &#123; if(s.equals(p)) return true; if(p.length() == 0) return false; return match(s, p, 0, 0); &#125;&#125; 动态规划解法思路使用二维$dp$数组存放匹配状态，$S[]$为字符串字符数组,$P[]$为模式串字符数组，状态转移共有以下三种情况： $S[i] == P[j]$ -&gt; $dp[i][j] = dp[i-1][j-1]$ $P[j] == ‘.’$ -&gt; $dp[i][j] = dp[i-1][j-1]$ $P[j] == ‘*’$ -&gt; 还需分两种情况: $S[i] != P[j]$ -&gt; $dp[i][j] = dp[i][j-2]$ $S[i] == P[j]$: $dp[i][j] = dp[i-1][j]$ a*作为多个a $dp[i][j] = dp[i][j-2]$ a*作为空 初始化边界条件版(常规)123456789101112131415161718192021222324252627282930class Solution &#123; public boolean isMatch(String s, String p) &#123; int col = s.length(); int row = p.length(); //建立一个boolean数组，数组长度为 row + 1 * col + 1，多的一列一行代表空串的情况 boolean[][] dp = new boolean[row+1][col+1]; dp[0][0] = true; //第一行剩余元素全部变为false，因为pattern如果是空串，那么只要s不是空串，都不能匹配 for(int i=1;i&lt;=col;i++) dp[0][i] = false; //初始化第0列，此时s是空串，所以只能是x*y*这种形式的 //注意，j-1代表的真实的p的索引 for(int j=1;j&lt;=row;j++) dp[j][0] = (j&gt;1) &amp;&amp; (p.charAt(j-1)=='*') &amp;&amp; dp[j-2][0]; //主体循环开始 for(int i=1;i&lt;=col;i++)&#123; for(int j=1;j&lt;=row;j++)&#123; //如果当前的pattern字符串是*，需要同时满足下面的两个条件，才能为true，此时s其实是固定住的，在思考的时候可以这么想 //1、如果往前数两行的位置可以匹配，那么这里的*可以代表空，此时可以匹配， //如果s是aa，p是a*的话，我们不能根据往前数两行来判断，这时必须满足p[j-2]==s[i-1] 或者说 p[j-2]是'.' if(p.charAt(j-1)=='*') dp[j][i] = dp[j-2][i] || (p.charAt(j-2)==s.charAt(i-1) || p.charAt(j-2)=='.') &amp;&amp; dp[j][i-1]; else dp[j][i] = (p.charAt(j-1)=='.' || p.charAt(j-1)==s.charAt(i-1)) &amp;&amp; dp[j-1][i-1]; &#125; &#125; return dp[row][col]; &#125;&#125; 边界条件融入循环(大佬版)123456789101112131415161718class Solution &#123; public boolean isMatch(String s, String p) &#123; int n = s.length(), m = p.length(); char[] S = s.toCharArray(), P = p.toCharArray(); boolean[][] dp = new boolean[n+1][m+1]; dp[0][0] = true; for (int i = 0; i &lt;= n; i++) &#123; for (int j = 1; j &lt;= m; j++) &#123; if (j &gt; 1 &amp;&amp; P[j - 1] == '*') &#123; dp[i][j] = dp[i][j - 2] || (i &gt; 0 &amp;&amp; (S[i - 1] == P[j - 2] || P[j - 2] == '.') &amp;&amp; dp[i - 1][j]); &#125; else &#123; dp[i][j] = i &gt; 0 &amp;&amp; dp[i - 1][j - 1] &amp;&amp; (S[i - 1] == P[j - 1] || P[j - 1] == '.'); &#125; &#125; &#125; return dp[n][m]; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
        <tag>递归</tag>
        <tag>面试题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVD分解和应用]]></title>
    <url>%2F2018%2F06%2F27%2FSVD%E5%88%86%E8%A7%A3%E5%92%8C%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[奇异值分解详解 奇异值奇异值是矩阵里的概念，一般通过奇异值分解定理求得。设$A$为$m*n$阶矩阵，$q=min(m,n)$，$A*A$的$q$个非负特征值的算术平方根叫作$A$的奇异值。 奇异值分解奇异值分解是一个能适用于任意的矩阵的一种分解的方法假设A是一个$N*M$的矩阵，那么得到的U是一个$N*N$的方阵（里面的向量是正交的，$U$里面的向量称为左奇异向量），$\Sigma$是一个$N*M$的矩阵（除了对角线的元素都是0，对角线上的元素称为奇异值），$V^T$($V$的转置)是一个$N*N$的矩阵，里面的向量也是正交的，$V$里面的向量称为右奇异向量），从图片来反映几个相乘的矩阵的大小: 示例1234567891011A = np.array([[1, 3, 4], [5, 3, 1], [4, 9, 3], [7, 1, 4]]) U, S, V = np.linalg.svd(A) S1 = np.zeros(A.shape) for i in range(3): S1[i][i] = S[i] print(U) print(S1) print(V) U S V 那么奇异值和特征值是怎么对应起来的呢？首先，$A^T$*$A$，将会得到一个方阵，我们用这个方阵求特征值可以得到：这里得到的$V$，就是我们上面的右奇异向量。此外我们还可以得到：这里的$σ$就是上面说的奇异值，$u$就是上面说的左奇异向量。奇异值$σ$跟特征值类似，在矩阵$Σ$中也是从大到小排列，而且$σ$的减少特别的快，在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上了。也就是说，我们也可以用前$r$大的奇异值来近似描述矩阵，这里定义一下部分奇异值分解：$r$是一个远小于$m$、$n$的数，这样矩阵的乘法看起来像是下面的样子：右边的三个矩阵相乘的结果将会是一个接近于$A$的矩阵，在这儿，$r$越接近于$n$，则相乘的结果越接近于$A$。而这三个矩阵的面积之和（在存储观点来说，矩阵面积越小，存储量就越小）要远远小于原始的矩阵$A$，我们如果想要压缩空间来表示原矩阵$A$，我们存下这里的三个矩阵：$U$、$Σ$、$V$就好了。 奇异值分解图片12345678910111213141516171819202122232425262728293031323334353637383940import numpy as npimport matplotlib.pyplot as pltdef imageSVD(file, percent): rgb = plt.imread(file) print(rgb.shape) r = np.array(rgb[:, :, 0]) g = np.array(rgb[:, :, 1]) b = np.array(rgb[:, :, 2]) u0, s0, v0 = np.linalg.svd(r) u1, s1, v1 = np.linalg.svd(g) u2, s2, v2 = np.linalg.svd(b) S0 = np.zeros(r.shape) S1 = np.zeros(r.shape) S2 = np.zeros(r.shape) num = int(min(r.shape[0], r.shape[1]) * percent) print(num) for i in range(num): #取RGB三通道前num个奇异值 S0[i][i] = s0[i] S1[i][i] = s1[i] S2[i][i] = s2[i] R = np.dot(np.dot(u0[:, :num], S0[:num, :num]), v0[:num, :]) G = np.dot(np.dot(u1[:, :num], S1[:num, :num]), v1[:num, :]) B = np.dot(np.dot(u2[:, :num], S2[:num, :num]), v2[:num, :]) RGB = np.stack((R, G, B), 2) #RGB矩阵堆叠，堆叠后维度(1000, 1000, 3) RGB[RGB &gt; 255] = 255 RGB[RGB &lt; 0] = 0 RGB = np.rint(RGB).astype('uint8') #化为最近整形 return RGBif __name__ == '__main__': file = 'meizi.jpg' RGB = plt.imread(file) RGB = imageSVD(file, 0.1) # plt.imsave('meizi_svd.jpg',RGB) plt.imshow(RGB) plt.show() 原图 0.1倍奇异值 0.05倍奇异值 0.01倍奇异值]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>PCA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试题17：打印从1到最大的n位数]]></title>
    <url>%2F2018%2F06%2F25%2F%E9%9D%A2%E8%AF%95%E9%A2%9817%EF%BC%9A%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的三位数999 注意：本题实际考察大数问题，直接循环打印整形会溢出，采用字符串模拟加法12345678910111213141516171819202122232425262728293031323334353637383940public static void printToMax(int n) &#123; if(n &lt;= 0) return; char [] nums = new char[n+1]; Arrays.fill(nums, '0'); while(increase(nums)) &#123; printNum(nums); &#125;&#125;public static boolean increase(char[] nums) &#123; int len = nums.length; if(nums[len-1] == '1') return false; int takeOver = 1; for(int i = 0; i &lt; len; i++) &#123; if(takeOver != 0) &#123; int sum = nums[i] + 1; if((char)sum &gt; '9') &#123; takeOver = 1; nums[i] = '0'; &#125;else &#123; takeOver = 0; nums[i] = (char)sum; &#125; &#125; &#125; return true;&#125;public static void printNum(char [] nums) &#123; String str = ""; int i = nums.length-2; //从倒数第二位开始 boolean flag = false; while(i &gt;= 0) &#123; //倒序打印 if(nums[i] != '0') flag = true; if(flag) &#123; str += nums[i]; &#125; i--; &#125; if(str == "") return; else System.out.println(str);&#125; 回溯全排列思路打印从1到最大的n位数其实就是n个0-9的数字的全排列，因而可用回溯法求解12345678910111213141516171819202122// 回溯全排列public static void strDFS(String str, int n, int index) &#123; if(n &lt;= 0) return; // 处理n小于等于0的情况 if(index == n) &#123; // 去除字符串前面多余的0 int isNot = 0; // 第一个不为0的下标 for(int i = 0; i &lt; str.length(); i++) &#123; if(str.charAt(i) != '0') &#123; isNot = i; break; &#125; isNot = n; &#125; if(isNot == n) return; else System.out.println(str.substring(isNot, str.length())); return; &#125; for(int i = 0; i &lt;= 9; i++) &#123; str += (char)(i+48); strDFS(str, n, index+1); str = str.substring(0, str.length()-1); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>面试题</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树深度]]></title>
    <url>%2F2018%2F06%2F22%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[二叉树最大深度给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。说明: 叶子节点是指没有子节点的节点。 示例：给定二叉树 [3,9,20,null,null,15,7]， 3 / \ 9 20 / \ 15 7 返回它的最大深度3 。 DFS实现1234567891011121314151617/** * 二叉树节点定义. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int maxDepth(TreeNode root) &#123; if(root == null) return 0; int ldeepth = maxDepth(root.left); int rdeepth = maxDepth(root.right); return Math.max(ldeepth, rdeepth) + 1; &#125;&#125; 二叉树最小深度题目描述给定一个二叉树，找出其最小深度。最小深度是从根节点到最近叶子节点的最短路径上的节点数量。说明: 叶子节点是指没有子节点的节点。 示例:给定二叉树 [3,9,20,null,null,15,7], 3 / \ 9 20 / \ 15 7 返回它的最小深度2 。 DFS实现注意：求最小深度，需要考虑单子树和双子树两种情况，双子树取左右子树中的较小值；单子树取最大深度123456789101112131415161718192021/** * 二叉树节点定义. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int minDepth(TreeNode root) &#123; int deepth = 0; if(root == null) return 0; if(root.left == null &amp;&amp; root.right == null) return 1; int l = minDepth(root.left) + 1; int r = minDepth(root.right) + 1; if(root.left == null || root.right == null) deepth = Math.max(l, r); // 单子树取最大深度 else deepth = Math.min(l, r); // 双子树取最小深度 return deepth; &#125;&#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>二叉树</tag>
        <tag>DFS</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[矩阵中的最长递增路径]]></title>
    <url>%2F2018%2F06%2F22%2F%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[题目描述给定一个整数矩阵，找出最长递增路径的长度。对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。 示例 1:输入: nums =[ [9,9,4], [6,6,8], [2,1,1]]输出: 4解释: 最长递增路径为 [1, 2, 6, 9]。 示例 2:输入: nums =[ [3,4,5], [3,2,6], [2,2,1]]输出: 4解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。 回溯法1234567891011121314151617181920212223242526272829303132public class Solution &#123; static int [] ro = &#123;-1, 1, 0, 0&#125;; static int [] co = &#123;0, 0, -1, 1&#125;; static int maxLen = 1; static void dfs(int [][] matrix, List&lt;Integer&gt; path, int row, int col)&#123; List&lt;Integer&gt; res = new ArrayList(path); for(int i = 0; i &lt; 4; i++)&#123; int r = row + ro[i]; int c = col + co[i]; if(r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; matrix.length &amp;&amp; c &lt; matrix[0].length &amp;&amp; matrix[r][c] &gt; matrix[row][col])&#123; res.add(matrix[r][c]); if(res.size() &gt; maxLen)&#123; maxLen = res.size(); &#125; // System.out.println(res); dfs(matrix, res, r, c); res.remove(res.size()-1); &#125; &#125; &#125; public static int longestIncreasingPath(int[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0; for(int i=0; i&lt;matrix.length; i++) &#123; for(int j=0; j&lt;matrix[i].length; j++) &#123; List &lt;Integer&gt; path = new ArrayList(); path.add(matrix[i][j]); dfs(matrix, path, i, j); &#125; &#125; return maxLen; &#125;&#125; 动态规划+DFS这道题给我们一个二维数组，让我们求矩阵中最长的递增路径，规定我们只能上下左右行走，不能走斜线或者是超过了边界。那么这道题的解法要用递归和DP来解，用DP的原因是为了提高效率，避免重复运算。我们需要维护一个二维动态数组dp，其中dp[i][j]表示数组中以(i,j)为起点的最长递增路径的长度，初始将dp数组都赋为0，当我们用递归调用时，遇到某个位置(x, y), 如果dp[x][y]不为0的话，我们直接返回dp[x][y]即可，不需要重复计算。我们需要以数组中每个位置都为起点调用递归来做，比较找出最大值。在以一个位置为起点用DFS搜索时，对其四个相邻位置进行判断，如果相邻位置的值大于上一个位置，则对相邻位置继续调用递归，并更新一个最大值，搜素完成后返回即可，参见代码如下：1234567891011121314151617181920212223242526public class Solution &#123; static int [] ro = &#123;-1, 1, 0, 0&#125;; static int [] co = &#123;0, 0, -1, 1&#125;; static int dfs(int [][] matrix, int row, int col, int [][] dp)&#123; if(dp[row][col] != 0) return dp[row][col]; // 递归出口,若已访问则返回该节点的最长递增路径长度 dp[row][col] = 1; for(int i = 0; i &lt; 4; i++)&#123; int r = row + ro[i]; int c = col + co[i]; if(r &gt;= 0 &amp;&amp; c &gt;= 0 &amp;&amp; r &lt; matrix.length &amp;&amp; c &lt; matrix[0].length &amp;&amp; matrix[r][c] &gt; matrix[row][col])&#123; dp[row][col] = Math.max(dp[row][col], dfs(matrix, r, c, dp)+1); // 若满足递增条件且不越界则继续寻找下个节点，并更新dp数组 &#125; &#125; return dp[row][col]; &#125; public static int longestIncreasingPath(int[][] matrix) &#123; if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return 0; int max = 0; int [][] dp = new int [matrix.length][matrix[0].length]; for(int i=0; i&lt;matrix.length; i++) &#123; for(int j=0; j&lt;matrix[i].length; j++) &#123; max = Math.max(max, dfs(matrix, i, j, dp)); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
        <tag>动态规划</tag>
        <tag>DFS</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytorch0.4.0入门教程]]></title>
    <url>%2F2018%2F06%2F21%2FPytorch0-4-0%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[pytorch0.4支持了Windows系统的开发，在首页即可使用pip安装pytorch和torchvision。 说白了，以下文字就是来自官方文档60分钟入门的简要翻译. pytorch是啥python的科学计算库，使得NumPy可用于GPU计算，并提供了一个深度学习平台使得灵活性和速度最大化 入门Tensors(张量) Tensors与NumPy的ndarrays类似，另外可以使用GPU加速计算 未初始化的5*3的矩阵:x = torch.empty(5, 3) 随机初始化的矩阵:x = torch.rand(5, 3) 全零矩阵,定义数据类型:x = torch.zeros(5, 3, dtype=torch.long) 由数据构造矩阵:x = torch.tensor([5.5, 3]) 由已存在张量构造矩阵，性质与之前张量一致: 12x = x.new_ones(5, 3, dtype=torch.double) x = torch.randn_like(x, dtype=torch.float) 获取维度:print(x.size()) Operations有多种operation的格式，这里考虑加法 12y = torch.rand(5, 3)print(x + y) 1print(torch.add(x, y)) 123result = torch.empty(5, 3)torch.add(x, y, out=result)print(result) 123# adds x to yy.add_(x)print(y) operations中需要改变张量本身的值，可以在operation后加,比如`x.copy(y), x.t_()` 索引:print(x[:, 1]) 改变维度:x.view(-1, 8) 和Numpy的联系torch tensor 和 numpy array之间可以进行相互转换，他们会共享内存位置，改变一个，另一个会跟着改变。 tensor to array1234a = torch.ones(5)b = a.numpy()a.add_(1)print(a,b) array to tensor123456import numpy as npa = np.ones(5)b = torch.from_numpy(a)np.add(a, 1, out=a)print(a)print(b) CUDA Tensorstensor可以使用.to方法将其移动到任何设备。 123456789# let us run this cell only if CUDA is available# We will use ``torch.device`` objects to move tensors in and out of GPUif torch.cuda.is_available(): device = torch.device("cuda") # a CUDA device object y = torch.ones_like(x, device=device) # directly create a tensor on GPU x = x.to(device) # or just use strings ``.to("cuda")`` z = x + y print(z) print(z.to("cpu", torch.double)) # ``.to`` can also change dtype together! Autograd(自动求导)pytorch神经网络的核心模块就是autograd，autograd模块对Tensors上的所有operations提供了自动求导。 Tensortorch.Tensor是模块中的核心类，如果设置属性.requires_grad = True,开始追踪张量上的所有节点操作，指定其是否计算梯度。使用.backward()方法进行所有梯度的自动求导，张量的梯度会累积到.grad属性中。 .detach()停止张量的追踪，从梯度计算中分离出来；另外在评估模型时一般使用代码块with torch.no_grad():,因为模型中通常训练的参数也会有.requires_grad = True,这样写可以停止全部张量的梯度更新。 Function类是autograd的变体，Tensor和Function相互交错构建成无环图，编码了完整的计算过程，每个Variable(变量)都有.grad_fn属性，引用一个已经创建了的Tensor的Function. 如上，使用.backward()计算梯度。如果张量是一个标量(只有一个元素),不需要对.backward()指定参数；如果张量不止一个元素，需要指定.backward()的参数，其匹配张量的维度。 1234567891011121314151617import torchx = torch.ones(2, 2, requires_grad=True)print(x)y = x + 2print(y)print(y.grad_fn)z = y * y * 3out = z.mean()print(z, out)a = torch.randn(2, 2)a = ((a * 3) / (a - 1))print(a.requires_grad)a.requires_grad_(True) # 改变a张量内在的属性print(a.requires_grad)b = (a * a).sum()print(b.grad_fn) Gradients反向传播时，由于out是一个标量，out.backward()等效于out.backward(torch.tensor(1)) 123456789101112131415161718192021out.backward()print(x.grad)x = torch.randn(3, requires_grad=True)y = x * 2while y.data.norm() &lt; 1000: y = y * 2print(y)gradients = torch.tensor([0.1, 1.0, 0.0001], dtype=torch.float)y.backward(gradients)print(x.grad)print(x.requires_grad)print((x ** 2).requires_grad)with torch.no_grad(): print((x ** 2).requires_grad) 神经网络神经网络可以用torch.nn构建。nn依赖于autograd定义模型和求导，nn.Module定义网络层，方法forward(input)返回网络输出。 举例说明，如下是对数字图片分类的卷积网络架构。 这是一个简单的前馈神经网络，将输入数据依次通过几层网络层后最终得到输出。 神经网络典型的训练步骤如下： 定义神经网络及学习的参数(权重) 迭代输入数据 将输入数据输入到网络结构中 计算代价函数 误差向后传播 更新网络权重 weight = weight - learning_rate * gradient 定义网络123456789101112131415161718192021222324252627282930313233343536373839import torchimport torch.nn as nnimport torch.nn.functional as Fclass Net(nn.Module): def __init__(self): super(Net, self).__init__() # 1 input image channel, 6 output channels, 5x5 square convolution # kernel self.conv1 = nn.Conv2d(1, 6, 5) self.conv2 = nn.Conv2d(6, 16, 5) # an affine operation: y = Wx + b self.fc1 = nn.Linear(16 * 5 * 5, 120) self.fc2 = nn.Linear(120, 84) self.fc3 = nn.Linear(84, 10) def forward(self, x): # Max pooling over a (2, 2) window x = F.max_pool2d(F.relu(self.conv1(x)), (2, 2)) # If the size is a square you can only specify a single number x = F.max_pool2d(F.relu(self.conv2(x)), 2) x = x.view(-1, self.num_flat_features(x)) x = F.relu(self.fc1(x)) x = F.relu(self.fc2(x)) x = self.fc3(x) return x def num_flat_features(self, x): size = x.size()[1:] # all dimensions except the batch dimension num_features = 1 for s in size: num_features *= s return num_featuresnet = Net()print(net) out: 1234567Net( (conv1): Conv2d(1, 6, kernel_size=(5, 5), stride=(1, 1)) (conv2): Conv2d(6, 16, kernel_size=(5, 5), stride=(1, 1)) (fc1): Linear(in_features=400, out_features=120, bias=True) (fc2): Linear(in_features=120, out_features=84, bias=True) (fc3): Linear(in_features=84, out_features=10, bias=True)) 可以仅定义forward()函数，当使用autograd时backward()被自动定义。可以在forward()函数中使用任何operation操作。 net.parameters()返回模型中的可学习参数。 123params = list(net.parameters())print(len(params))print(params[0].size()) # conv1's .weight 使所有参数的梯度归零然后开始计算梯度 12net.zero_grad()out.backward(torch.randn(1, 10)) 代价函数代价函数将(output,target)作为输入，计算output与target之间的距离。 nn模块中有几种不同的代价函数选择，最简单的是nn.MSELoss，计算均方误差 eg： 1234567output = net(input)target = torch.arange(1, 11) # a dummy target, for exampletarget = target.view(1, -1) # make it the same shape as outputcriterion = nn.MSELoss()loss = criterion(output, target)print(loss) 按照向后传播的方向传播loss，使用grad_fn可以查看整个流程的计算图 1234input -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; view -&gt; linear -&gt; relu -&gt; linear -&gt; relu -&gt; linear -&gt; MSELoss -&gt; loss 使用loss.backward()，流程中所有requres_grad=True的张量累积它的梯度至.grad 123print(loss.grad_fn) # MSELossprint(loss.grad_fn.next_functions[0][0]) # Linearprint(loss.grad_fn.next_functions[0][0].next_functions[0][0]) # ReLU 向后传播loss.backward()传播误差， 123456789net.zero_grad() # zeroes the gradient buffers of all parametersprint('conv1.bias.grad before backward')print(net.conv1.bias.grad)loss.backward()print('conv1.bias.grad after backward')print(net.conv1.bias.grad) 更新权重误差每次传播后，需要对权重进行更新，简单的更新方式如下： 123learning_rate = 0.01for f in net.parameters(): f.data.sub_(f.grad.data * learning_rate) torch.optim实现了这一过程，并有着不同的更新规则GD, Nesterov-SGD, Adam, RMSProp， 1234567891011import torch.optim as optim# create your optimizeroptimizer = optim.SGD(net.parameters(), lr=0.01)# in your training loop:optimizer.zero_grad() # zero the gradient buffersoutput = net(input)loss = criterion(output, target)loss.backward()optimizer.step() # Does the update note: 每次迭代时由于梯度的累积，需要手动将梯度归零optimizer.zero_grad()]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pytorch0.4.0更新]]></title>
    <url>%2F2018%2F06%2F21%2FPytorch0.4.0%E6%9B%B4%E6%96%B0%2F</url>
    <content type="text"><![CDATA[一、重大核心变化包括 Tensor/Variable 合并 零维张量 数据类型 迁移指南 二、现添加的新特征包括 Tensors： 全面支持高级索引 快速傅立叶变换 神经网络： 计算时的存储权衡 bottleneck-识别代码中热点（hotspots）的工具 torch.distributions 24 个基础的概率分布 增加cdf、方差、信息熵、困惑度等 分布式训练 易于使用的 Launcher utility NCCL2 后端 C++拓展 Windows 支持 ONNX 改进 RNN 支持 三、性能改进四、Bug 修复五、torchvision的一些变化1.torchvision.transform中函数torchvision.transforms.`Scale(*args, **kwargs)即将被函数torchvision.transforms.Resize`(size, interpolation=2)代替。（参考官方文档：点击打开链接） 2.torchvision.transform中函数torchvision.transforms.`RandomSizedCrop(*args, **kwargs)即将被函数torchvision.transforms.RandomResizedCrop`(size, scale=(0.08, 1.0), ratio=(0.75, 1.3333333333333333), interpolation=2)代替。（参考官方文档：点击打开链接） 六、安装方式——Windows安装【方法一】pip直接安装。官网（点击打开链接）给出的安装步骤如下图所示（根据CUDA版本以及Python版本选择）。 Run this command: 12pip3 install http://download.pytorch.org/whl/cu90/torch-0.4.0-cp36-cp36m-win_amd64.whl pip3 install torchvision 这里我是下载好torch-0.4.0-cp36-cp36m-win_amd64.whl文件到本地之后才安装的。进入Anaconda Prompt，然后进入文件所在目录： 1.打开cmd命令提示符，先利用anaconda创建一个虚拟环境，命名为pytorch41conda create -n pytorch4 python=3.6 2.激活刚才创建好的虚拟环境1activate pytorch4 3.安装pytorch0.4.0 1pip install torch-0.4.0-cp35-cp35m-win_amd64.whl 注：根据自己的配置选择whl下载来链接 4.安装torchvision1pip install torchvision 简单测试安装是否成功123pythonimport torchprint(torch.__version__) 如果输出0.4.0，那么恭喜Windows下的PyTorch0.4.0安装成功！]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>PyTorch</tag>
        <tag>深度学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整数拆分]]></title>
    <url>%2F2018%2F06%2F20%2F%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86%2F</url>
    <content type="text"><![CDATA[整数拆分给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。例如，给定 n = 2，返回1（2 = 1 + 1）；给定 n = 10，返回36（10 = 3 + 3 + 4）。注意：你可以假设 n 不小于2且不大于58。 算法思想任意大于等于2的正整数n都可以拆分为两个正整数之和，可以用dp数组存放n拆分后的乘积最大值，10 = 3 + 3 + 4可以拆分为10 = 6 + 4, dp[10] = dp[6] + dp[4]，而dp[6]和dp[4]又可以继续划分为dp[3] dp[3]和d[2] dp[2]…满足最优子结构性质，状态转移方程如下：$dp[n] = max\langle dp[1]\cdot dp[n-1], dp[2]\cdot dp[n-2]\cdots dp[i]\cdot dp[n-i]\rangle$ 动态规划123456789101112131415class Solution &#123; public int integerBreak(int n) &#123; int [] dp = new int [n+1]; if(n == 2) return 1; if(n == 3) return 2; for(int i = 2; i &lt;= n; i++)&#123; for(int j = 1; j &lt;= i/2; j++)&#123; if(dp[j] * dp[i-j] &gt;= dp[i])&#123; dp[i] = Math.max(dp[j] * dp[i-j], i); &#125; &#125; &#125; return dp[n]; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[买卖股票的最佳时机]]></title>
    <url>%2F2018%2F06%2F20%2F%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[买卖股票的最佳时机 II题目描述给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 示例 1:输入: [7,1,5,3,6,4]输出: 7解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。 示例 2:输入: [1,2,3,4,5]输出: 4解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。 示例 3:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 普通解法思路：由于买卖次数无限，所以只要能获利就进行买卖，这样能保证所有利润都吃到自然利润最大。12345678910111213class Solution &#123; public int maxProfit(int[] prices) &#123; int profit = 0; int sum = 0; for(int i = 0; i &lt; prices.length-1; i++)&#123; profit = prices[i+1] - prices[i]; if(profit &gt; 0)&#123; sum += profit; &#125; &#125; return sum; &#125;&#125; 动态规划思路：用两个数组分别存放当前股票下两种状态——买和卖的最大值，最后卖出的即为最大利润1234567891011121314class Solution &#123; public int maxProfit(int[] prices) &#123; int len = prices.length; if(len == 0) return 0; int [] buy = new int[len+1]; int [] sell = new int[len+1]; buy[0] = -prices[0]; for(int i = 0; i &lt; len; i++)&#123; buy[i+1] = Math.max(buy[i], sell[i]-prices[i]); sell[i+1] = Math.max(sell[i], buy[i]+prices[i]); &#125; return sell[len]; &#125;&#125; 最佳买卖股票时机含冷冻期题目描述给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）: 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。 示例:输入: [1,2,3,0,2]输出: 3解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出] 思路与上一题不同之处在于加入了一个冷冻期Cooldown，每支股票对应三种状态， 因此需要维护三个一维数组buy, sell，和rest。其中：buy[i]表示在第i天之前最后一个操作是买，此时的最大收益。sell[i]表示在第i天之前最后一个操作是卖，此时的最大收益。rest[i]表示在第i天之前最后一个操作是冷冻期，此时的最大收益。 写出递推式为： buy[i] = max(rest[i-1] - price, buy[i-1]) sell[i] = max(buy[i-1] + price, sell[i-1]) rest[i] = max(sell[i-1], buy[i-1], rest[i-1]) 另外，由于冷冻期的存在，我们可以得出rest[i] = sell[i-1]，这样，我们可以将上面三个递推式精简到两个： buy[i] = max(sell[i-2] - price, buy[i-1]) sell[i] = max(buy[i-1] + price, sell[i-1]) 动态规划123456789101112131415161718192021222324252627282930313233// 三个状态class Solution &#123; public int maxProfit(int[] prices) &#123; int len = prices.length; if(len == 0) return 0; int [] buy = new int [len+1]; int [] sell = new int [len+1]; int [] rest = new int [len+1]; buy[0] = -prices[0]; for(int i = 0; i &lt; len; i++)&#123; buy[i+1] = Math.max(rest[i]-prices[i], buy[i]); sell[i+1] = Math.max(buy[i]+prices[i], sell[i]); rest[i+1] = Math.max(Math.max(sell[i], buy[i]), rest[i]); &#125; return sell[len]; &#125;&#125;// 由rest[i] = sell[i-1]精简为两个状态class Solution &#123; public int maxProfit(int[] prices) &#123; int len = prices.length; if(len == 0) return 0; int [] buy = new int [len+1]; int [] sell = new int [len+1]; buy[1] = -prices[0]; for(int i = 1; i &lt; len; i++)&#123; buy[i+1] = Math.max(sell[i-1]-prices[i], buy[i]); sell[i+1] = Math.max(buy[i]+prices[i], sell[i]); &#125; return sell[len]; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[苏州项目USB通信协议]]></title>
    <url>%2F2018%2F06%2F12%2F%E8%8B%8F%E5%B7%9E%E9%A1%B9%E7%9B%AE%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[版本号：0.01发行日期：2018-JUN-12 HID设备符兼容： 微软Windows 98、Windows2000、NT、XP、VISTA、WIN7、WIN8、WIN10，免驱动安装； Linux操作系统，免驱动安装。 苹果Mac操作系统，免驱动安装 VID: 未定PID: 未定 液晶屏信息 写入参数与命令均为16进制值。 系统信息命令：01写入：01 返回：ID:178636793830;sRev:1.00;hRev:1.00;Cmp:2018-06-08. 说明： ID：唯一序列号 sRev：软件版本号 hRev：硬件版本号 Cmp：发行日期 日期时间命令：02写入：02 返回：DtTm:18-06-12 13:43:33;CardCap:501219328 bytes. 说明： DtTm：日期与时间 CardCap：卡容量 日期时间校正命令：03写入：03 18 06 12 13 45 12 返回：DtTm:18-06-12 13:45:12; 说明： DtTm：日期与时间 用户名与密码主命令：04检查用户名与密码子命令：04 00 写入：DtTm:18-06-12 13:45:12; 返回：Rslt:0 结果为0表示已设置，不为0则未设置。 设置用户名与密码子命令：04 01 写入：04 01 0C 54 65 73 74 55 73 65 72 4E 61 6D 31 0F 54 65 73 74 50 61 73 73 77 6F 72 64 31 32 33 返回：Name:TestUserNam1;Pasd:TestPassword123;Rslt:0. 说明： 帧结构： 04 01 + 用户名称长度 + 用户名 +密码长度 + 密码 上例中： 04 01 =&gt; 主命令 + 子命令 0C =&gt; 用户名长度 54 65 73 74 55 73 65 72 4E 61 6D 31 =&gt; 用户名 0F =&gt; 密码长度 54 65 73 74 50 61 73 73 77 6F 72 64 31 32 33 =&gt; 密码 Name：用户名 =&gt; 取值范围：限十进制33至十进制122之间的可打印字符，共90个字符。 取值长度：最大16个字符长度。 Pasd：用户密码 =&gt; 取值范围：限十进制33至十进制122之间的可打印字符，共90个字符。 取值长度：最大16个字符长度。 Rslt：执行结果 结果 =0：表示已执行成功 =1：执行失败 =2：执行失败，名称非法的字符值,不是可打印字符 =3：执行失败，密码非法的字符值,不是可打印字符 登录系统子命令：04 02 写入：04 02 0C 54 65 73 74 55 73 65 72 4E 61 6D 31 0F 54 65 73 74 50 61 73 73 77 6F 72 64 31 32 33 返回：Rslt:0 结果为0表示已登录系统，不为0则为登录失败。 帧结构与“设置用户名与密码子命令”相同。 读出用户名与密码子命令：04 03 写入：04 03 返回：Name:TestUserNam1;Pasd:TestPassword123. 说明： Name：用户名 =&gt; TestUserNam1 Pasd：用户密码 =&gt; TestPassword123 读取模具检修次数命令：05写入：05 返回：ModiTms:00000. 说明： 模具检修次数&quot;ModiTms&quot; 设定服务器IP地址和端口命令：06写入：06 11 77 77 77 2E 73 6D 61 72 74 77 61 6C 65 2E 63 6F 6D 00 28 返回：IP:www.smartwale.com;Port:10240. Rslt：执行结果 结果 =0：表示已执行成功 =4：域名或IP地址长度超过32个字符 =5：端口号过大或过小 =6：域名中包含非法字符,取值范围：限十进制33至十进制122之间的可打印字符，共90个字符。 说明： 帧结构： 06 + 域名[或IP地址]长度 + 域名[或IP地址] + 2字节端口号 上例中： 命令： 06 IP地址长度： 11 域名[或IP地址]： 77 77 77 2E 73 6D 61 72 74 77 61 6C 65 2E 63 6F 6D ==&gt; www.smartwale.com 端口号： 00 28 ==&gt; 10240; 注意： 端口号取值范围：1024 ≤ 取值范围 ≤ 60000 读取服务器IP地址和端口命令：07写入：07 返回：IP:www.smartwale.com;Port:10240. 读取所有WIFI-AP名称命令：08读取WIFI-AP数量：08 00 写入：08 00 返回：QtyAP:06. 未就绪时返回：Rslt:6 说明： * 就绪时返回已找到的WIFI-AP数量; * 未就绪返回错误代码&quot;Rslt:6&quot;; 读取指定的第n个WIFI-AP的名称、端口等参数：08 01 写入：08 01 01 返回：Numbxx:&lt;加密方式&gt;,&lt;名称&gt;,&lt;信号强度&gt;,&lt;MAC地址&gt;,&lt;信道号&gt; 例： Numb01:4,&quot;ABC&quot;,-87,&quot;0c:82:68:bf:01:16&quot;,1 说明： 写入格式：08 01 + 第n个WIFI-AP 加密方式： =0：开放 =1：WEP =2：WPA_PSK =3：WPA_2PSK =4：WPA_WPA2_PSK 设置需要连接的WIFI-AP、密码命令：09写入：09 03 00 41 42 43 返回：NamAP:ABC;Password:Null. 说明： 写入格式：09 + AP名称长度 + 密码长度 + AP名称 + 密码 返回格式： AP名称：NamAP:ABC; ==&gt; 长度限制16个字符，限可打印字符; 访问密码：Password:Null. ==&gt; 长度限制16个字符，限可打印字符; 读取已设定的AP名称与密码：0A写入：0A 返回：NamAP:ABC;Password:Null. 说明： 返回格式： NamAP:ABC;Password:Null. 更新AP名称列表：0B写入：0B 返回：Rslt:0 清除模具检修次数命令：0C写入：0C 返回：Rslt:0 读取当前要写入的文件编号：0D写入：0D 返回：FilNumb:0000001;ReplenNumb:0000000. 说明： FilNo.: ==&gt; 当前已写入的文件编号; ReplenNo.: ==&gt; 插上USB后将上载的文件编号. 读取当前系统的状态命令：0E写入：0E 返回：AP:0;Svr:0;Batt:355. 说明： AP: ==&gt; WIFI模组连接主站状态; =2: 故障 =1: 已连接 =0: 未连接 Svr: ==&gt; 服务器连接状态; =1: 曾经连接成功 =0: 从未连接成功 Batt: ==&gt; 锂电池电压,&quot;355&quot;表示3.55V.]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>杂项</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫]]></title>
    <url>%2F2018%2F06%2F09%2FPython%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[文本爬取12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#encoding:utf-8import requests,urllib3.request,time,osimport random,csv,socket,http.clientfrom bs4 import BeautifulSoupdef get_contend(url, data = None): #获取网页中html代码 header=&#123;'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Accept-Encoding': 'zh-CN,zh;q=0.9', 'Accept-Language': 'zh-CN,zh;q=0.8', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36' &#125; timeout = random.choice(range(80,180)) while True: try: rep = requests.get(url,headers = header,timeout=timeout) rep.encoding = 'utf-8' break except socket.timeout as e: print ('3',e) time.sleep(random.choice.range(8,15)) except socket.error as e: print ('4',e) time.sleep(random.choice.range(20,60)) except http.client.BadStatusLine as e: print ('5',e) time.sleep(random.choice.range(30,80)) except http.client.IncompleteRead as e: print ('6',e) time.sleep(random.choice.range(5,15)) return rep.textdef get_data(html_text): final = [] bs = BeautifulSoup(html_text,'html.parser') #创建BeautifulSoup对象 body = bs.body #获取body部分 data = body.find('div',&#123;'id':'7d'&#125;) #找到需要爬取部分的div ul = data.find('ul') #获取ul部分 li = ul.find_all('li') #获取所有的li for day in li: #对li标签中内容进行遍历 temp = [] date =day.find('h1').string #找到日期 temp.append(date) #将日期添加到temp中 p = day.find_all('p') #找到每个li中的所有p标签 temp.append(p[0].string,) #第一个p标签中的天气状况添加到temp if p[1].find('span') == None: t_highest = None else: t_highest = p[1].find('span').string #找到最高温 t_highest = t_highest.replace('C','') t_lowest = p[1].find('i').string # 找到最低温 t_lowest = t_lowest.replace('C','') temp.append(t_highest) temp.append(t_lowest) final.append(temp) return finaldef write_data(data,name): #将数据写入文件 file_name = name with open(file_name, 'a', errors='ignore', newline='') as f: f_csv = csv.writer(f) f_csv.writerows(data)if __name__ == '__main__': url = 'http://www.weather.com.cn/weather/101190401.shtml' html = get_contend(url) result = get_data(html) print(result) write_data(result,'weather.csv') 图虫图片爬取按标签爬取12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273__author__ = 'Result_Lv'#encoding:utf-8import osimport jsonimport timeimport requestsimport numpy as npfrom urllib import request,errordef get_json(url): header = &#123;'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate, br', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36' &#125; rep = requests.get(url, headers = header) #请求json地址 json_dict = json.loads(rep.text) #解析json return json_dict #返回json字典def get_album_name(json_dict): album_name = [] postlist = json_dict['postList'] for i in range(len(postlist)): if postlist[i]['title'] == '': #图集标题为空时，命名为默认 album_name.append('Default' + str(i)) else: album_name.append(postlist[i]['title']) return album_namedef get_photo_id(json_dict): #获得所有照片的ID author_id = [] album_id = [] post_list = json_dict['postList'] for i in range(len(post_list)): #获取每个图集的照片ID photo_id = [] author_id.append(post_list[i]['author_id']) # 获取每个图集作者ID for j in range(len(post_list[i]['images'])): photo_id.append(post_list[i]['images'][j]['img_id']) #将所有每个图集里的照片全部添加到list album_id.append(photo_id) return author_id,album_iddef download_album(path,album_name,author_id,album_id): #下载图集 for i in range(len(album_id)): if not os.path.exists(path + album_name[i]): #若不存在对应图集的文件夹 try: os.makedirs(path + album_name[i]) #以图集名创建文件夹 except OSError as e: print(e) continue print('正在下载第' + str(i + 1) + '个图册:' + album_name[i]) for j in range(len(album_id[i])): fileurl = 'https://photo.tuchong.com/' + str(author_id[i]) +'/f/' + str(album_id[i][j]) + '.jpg' #生成每张照片Url filename = path + album_name[i] + '/' + str(j+1) + '.jpg' #命名照片 print(' 正在下载第' + str(j+1) + '张照片:' + fileurl) with open(filename,'w'): try: request.urlretrieve(fileurl,filename) #下载照片 time.sleep(np.random.rand()) #下载间隔 except error.HTTPError as e: print(e)if __name__ == '__main__': page = 3 #爬取页数 path = 'F:/少女/' #存放路径 for i in range(page): url = 'https://tuchong.com/rest/tags/少女/posts?page=' + str(i+1) + '&amp;count=20&amp;order=weekly' #tag的json地址 json_dict = get_json(url) album_name = get_album_name(json_dict) para = get_photo_id(json_dict) author_id = para[0] album_id = para[1] download_album(path,album_name,author_id,album_id) 按作者爬取12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#encoding:utf-8import osimport jsonimport timeimport requestsimport numpy as npfrom urllib import request,errordef get_json(url): #解析json header = &#123;'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8', 'Accept-Encoding': 'gzip, deflate, br', 'Accept-Language': 'zh-CN,zh;q=0.9', 'Connection': 'keep-alive', 'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36' &#125; rep = requests.get(url, headers = header) #请求json地址 json_dict = json.loads(rep.text) #解析json return json_dict #返回json字典def get_all_photo_id(json_dict): #获得所有照片的ID #post_id = [] photo_id = [] post_list = json_dict['post_list'] author_id = post_list[0]['author_id'] #获取作者ID author_name = post_list[0]['site']['name'] #获取作者姓名 # for i in range(len(post_list)): #获取所有图集ID # post_id.append(post_list[i]['post_id']) for i in range(len(post_list)): #获取每个图集的照片ID for j in range(len(post_list[i]['images'])): photo_id.append(post_list[i]['images'][j]['img_id']) #将所有每个图集里的照片全部添加到list return author_name,author_id,photo_iddef download_photo(path,author_id,photo_id): #下载全部照片 if not os.path.exists(path): os.makedirs(path) for i in range(len(photo_id)): filename = path + '/' + str(i+1) + '.jpg' fileurl = 'https://photo.tuchong.com/' + str(author_id) + '/f/' + str(photo_id[i]) + '.jpg' print(' 第' + str(i + 1) + '张图片:' + fileurl) with open(filename,'w'): try: request.urlretrieve(fileurl,filename) #下载照片 time.sleep(np.random.rand()) #下载间隔 except error.HTTPError as e: print(e)if __name__ == '__main__': page = 3 for i in range(page): url = 'https://thomaskksj.tuchong.com/rest/2/sites/395013/posts?count=20&amp;page=' + str(i + 1) #作者主页的json地址 print('正在下载第' + str(i+1) + '页:' + url) json_dict = get_json(url) para = get_all_photo_id(json_dict) author_name = para[0] author_id = para[1] photo_id = para[2] path = 'F:/' + author_name + '/page' + str(i + 1) download_photo(path,author_id,photo_id)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机器学习相关]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[集成学习集成学习（Ensemble learning）通过组合几种模型来提高机器学习的效果。与单一模型相比，该方法可以提供更好的预测结果。集成方法是将几种机器学习技术组合成一个预测模型的元算法，以达到减小方差（bagging）、偏差（boosting）或改进预测（stacking）的效果 BaggingBagging 是 bootstrap aggregation 的缩写。通过对训练样本重新采样的方法得到不同的训练样本集，在这些新的训练样本集上分别训练学习器，最终合并每一个学习器的结果，作为最终的学习结果，Bagging方法的具体过程如下图所示：在Bagging方法中，最重要的算法为随机森林Random Forest算法。在随机森林中，集成中的每棵树都是由从训练集中抽取的样本（即 bootstrap 样本）构建的。另外，与使用所有特征不同，这里随机选择特征子集，从而进一步达到对树的随机化目的。而最终结果采用Bagging的策略来获得，即多数投票机制因此，随机森林产生的偏差略有增加，但是由于对相关性较小的树计算平均值，估计方差减小了，导致模型的整体效果更好 BoostingBoosting算法中，学习器之间是存在先后顺序的，同时，每一个样本是有权重的，初始时，每一个样本的权重是相等的。首先，第1个学习器对训练样本进行学习，当学习完成后，增大错误样本的权重，同时减小正确样本的权重，再利用第2个学习器对其进行学习，依次进行下去，最终得到b个学习器，最终，合并这b个学习器的结果，同时，与Bagging中不同的是，每一个学习器的权重也是不一样的。Boosting方法的具体过程如下图所示：然后通过结合加权多数投票（分类）或加权求和（回归）以产生最终预测。Boosting 与 bagging 等方法的主要区别是基础学习器通过加权的数据进行顺序训练。在Boosting方法中，最重要的方法包括：AdaBoost和GBDT GBDT-梯度提升决策树梯度提升决策树Gradient Boosting Decision Tree是Gradient Boost框架下使用较多的一种模型，在梯度提升决策树中，其基学习器是分类回归树CART，使用的是CART树中的回归树。DT（Decision Tree）决策树。T自不必多说，作为一种常见的数据结构出现在各种算法当中。DT决策树，有分类树与回归树两种，之前文章中讲到了分类树，可参见 与 。回归树原理机制与分类树相似，区别在于分类树只有在叶子结点返回唯一分类，而回归树的每个节点都能返回预测值，通常为当前节点下所有样本的均值。B（Boosting）提升。即在原来模型的基础之上做进一步提升，提升决策树BDT的基本思想是采用多棵决策树串行建模。具体过程为，对于第一棵树之后的每一棵决策树，都基于前一棵决策树的输出进行二次建模，整个串行建模过程相当于对预测结果朝目标值进行修正。G（Gradient）梯度。梯度的大小反映了当前预测值与目标值之间的距离。因此，上面B所述的串行决策树模型，除开第一棵决策树使用原始预测指标建树，之后的每一棵决策树都用前一棵决策树的预测值与目标值计算出来的负梯度（可以理解为残差或者增量）来建树。这相当于给分错的样本加权多次分类，使样本最终的残差趋近于0。除开第一棵树的其他树，由于都是对目标的残差或增量进行建模预测，因此GBDT模型只需把过程中每一棵决策树的输出结果累加，便可得到最终的预测输出。 StackingStacking 是一种集成学习技术，通过元分类器或元回归聚合多个分类或回归模型。基础层次模型（level model）基于完整的训练集进行训练，然后元模型基于基础层次模型的输出进行训练。基础层次通常由不同的学习算法组成，因此 stacking 集成通常是异构的 正则化-防止过拟合，提高泛化能力在训练数据不够多时，或者overtraining时，常常会导致overfitting（过拟合），避免过拟合的方法有很多：early stopping、数据集扩增（Data augmentation）、正则化（Regularization）包括L1、L2（L2 regularization也叫weight decay），dropout等。采用正则化方法会自动削弱不重要的特征变量，自动从许多的特征变量中”提取“重要的特征变量，减小特征变量的数量级。 L1和L2正则为何可以减弱over-fitting，L1和L2正则有什么区别正则化通过降低模型的复杂性， 达到避免过拟合的问题。 L2正则化：在不使用L2正则化时。求导结果中w前系数为1，如今w前面系数为 1−ηλ/n ，由于η、λ、n都是正的。所以 1−ηλ/n小于1，它的效果是减小w。这也就是权重衰减（weight decay）的由来。更小的权值w，从某种意义上说，表示网络的复杂度更低，对数据的拟合刚刚好。 L1正则化当w为正时，更新后的w变小。当w为负时。更新后的w变大——因此它的效果就是让w往0靠。使网络中的权重尽可能为0，也就相当于减小了网络复杂度，防止过拟合 区别L1范数是指向量中各个元素绝对值之和，用于特征选择;L2范数 是指向量各元素的平方和然后求平方根，用于 防止过拟合，提升模型的泛化能力L1与L2区别：使用L1可以得到稀疏的权值；用L2可以得到平滑的权值 L1和L2正则化直观理解]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mnist识别]]></title>
    <url>%2F2018%2F06%2F09%2Fmnist%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[minist_mpl.py1234567891011121314151617181920212223242526272829303132333435#encoding:utf-8import kerasfrom keras.datasets import mnistfrom keras.models import Sequentialfrom keras.layers import Dense,Activation,Dropoutfrom keras.optimizers import SGD,Adadeltafrom keras.models import save_modelimport matplotlib.pyplot as plt(x_train,y_train),(x_test,y_test) = mnist.load_data()x_train = x_train.reshape(60000,28*28).astype('float32') #转换数据格式x_test = x_test.reshape(10000,28*28).astype('float32')x_train /= 255 #训练数据归一化x_test /= 255y_train = keras.utils.to_categorical(y_train,10) #one-hot编码y_test = keras.utils.to_categorical(y_test,10)print(x_train.shape,y_train.shape,x_test.shape,y_test.shape)modle = Sequential()#第一层隐层，64个神经元modle.add(Dense(256,activation='relu',input_dim=28*28))#第二层隐层，64个神经元modle.add(Dense(256,activation='relu'))modle.add(Dropout(0.5))#输出层，10个神经元modle.add(Dense(10,activation='softmax'))sgd = SGD(lr=0.01,decay=1e-6,momentum=0.9,nesterov=True)modle.compile(loss='categorical_crossentropy',optimizer='adagrad',metrics=['accuracy'])modle.fit(x_train,y_train,epochs=10,batch_size=128)score = modle.evaluate(x_test,y_test,batch_size=128)print(score)modle.save('MLP_minist.h5') 123456789101112131415161718192021222324252627282930313233343536373839#encoding:utf-8import kerasfrom keras.datasets import mnistfrom keras.models import Sequential,save_modelfrom keras.layers import Dense,Dropout,Flatten,Conv2D,MaxPooling2Dfrom keras.optimizers import SGD,Adadelta(x_train,y_train),(x_test,y_test) = mnist.load_data() #加载数据print(x_train.shape,x_test.shape)x_train = x_train.reshape(60000,28,28,1).astype('float32') #二维数据x_test = x_test.reshape(10000,28,28,1).astype('float32')x_train /= 255 #训练数据归一化x_test /= 255y_train = keras.utils.to_categorical(y_train) #one-hot编码y_test = keras.utils.to_categorical(y_test)num_classes = y_test.shape[1]model = Sequential() #创建序列模型model.add(Conv2D(64,(3,3),activation='relu',input_shape=(28,28,1))) #第一层卷积层model.add(MaxPooling2D(pool_size=(2,2))) #池化层model.add(Conv2D(64,(3,3),activation='relu')) #第二层卷积层model.add(MaxPooling2D(pool_size=(2,2))) #池化层model.add(Flatten()) #铺平当前节点model.add(Dense(128,activation='relu')) #全连接层model.add(Dropout(0.5)) #随机失活model.add(Dense(num_classes,activation='softmax'))model.compile(loss='categorical_crossentropy',optimizer='adam',metrics=['accuracy']) #编译模型model.fit(x_train,y_train,batch_size=128,epochs=10) #训练模型score = model.evaluate(x_test,y_test,batch_size=128) #评价模型print(score) #打印分类准确率model.save('CNN_minist.h5')]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>深度学习</tag>
        <tag>Keras</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表实现]]></title>
    <url>%2F2018%2F06%2F09%2F%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class LinkList &#123; private class Node&#123; private int data; private Node next; public Node() &#123; &#125; public Node(int data) &#123; this.data = data; &#125; &#125; private Node head; // 头指针 private Node tail = new Node(); // 尾指针 private int size; public void circulation() &#123; // 连接为循环链表 Node temp = head; while(temp.next != null) &#123; temp = temp.next; &#125; tail = temp; tail.next = head; &#125; public void add(int i) &#123; // 添加结点 if(head == null) &#123; // 没有头结点则添加头结点 head = new Node(1); size++; return; &#125; Node temp = head; while(temp.next != null) &#123; temp = temp.next; &#125; temp.next = new Node(i); size++; &#125; public void delete(int index) &#123; int i = 1; if(index &lt; 0) &#123; return; &#125; if(index == 0) &#123; // 删除头结点 head = head.next; size--; return; &#125; Node temp = head; while(temp.next != null) &#123; // 删除指定位置结点 if(index == i) &#123; temp.next = temp.next.next; size--; return; &#125; temp = temp.next; i++; &#125; &#125; public int size() &#123; return size; &#125; public void print() &#123; Node temp = head; for(int i = 0; i &lt; size(); ++i) &#123; System.out.print(temp.data + " "); temp = temp.next; &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树实现]]></title>
    <url>%2F2018%2F06%2F09%2F%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[结点结构12345678910111213class TreeNode&lt;T&gt;&#123; public T data; public TreeNode&lt;T&gt; left; public TreeNode&lt;T&gt; right; public TreeNode(T data, TreeNode&lt;T&gt; left, TreeNode&lt;T&gt; right) &#123; this.data = data; this.left = left; this.right = right; &#125;&#125; 先序创建二叉树123456789101112131415161718public class BinaryTree&lt;T&gt;&#123; /* * 先序创建二叉树 * 返回：根节点 */ public TreeNode&lt;T&gt; creatBinaryPre(LinkedList&lt;T&gt; treeData) &#123; TreeNode&lt;T&gt; root=null; T data=treeData.removeFirst(); if (data!=null) &#123; root=new TreeNode&lt;T&gt;(data, null, null); root.left=creatBinaryPre(treeData); root.right=creatBinaryPre(treeData); &#125; return root; &#125; 先序遍历二叉树123456789101112/* * 先序遍历二叉树（递归） */ public void PrintBinaryTreePreRecur(TreeNode&lt;T&gt; root) &#123; if (root!=null) &#123; System.out.print(root.data); PrintBinaryTreePreRecur(root.left); PrintBinaryTreePreRecur(root.right); &#125; &#125;]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java继承类]]></title>
    <url>%2F2018%2F06%2F09%2FJava%E7%BB%A7%E6%89%BF%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[父类12345678class Privilege&#123; String name; Map&lt;String, Integer&gt; Privileges = new HashMap&lt;&gt;(); public void setPrivileges(Map&lt;String, Integer&gt; Privileges) &#123; this.Privileges = Privileges; &#125;&#125; 子类继承12345class Role extends Privilege&#123; public Role(String name)&#123; this.name = name; &#125;&#125; 子类继承12345class User extends Privilege&#123; public User(String name)&#123; this.name = name; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[快排]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[父类123456789101112131415161718192021222324252627 public static void quickSort(int arr[], int low, int high) &#123; int l = low; int h = high; int key = arr[low]; if(l &gt;= h) &#123; return; &#125;// 划分集合 while(l &lt; h) &#123; while(arr[h] &gt;= key &amp;&amp; h &gt; l) &#123; h--; &#125; arr[l] = arr[h]; while(arr[l] &lt;= key &amp;&amp; l &lt; h) &#123; l++; &#125; arr[h] = arr[l]; &#125; arr[l] = key;// 递归调用 if(l &gt; low) &#123; quickSort(arr, low, l-1); &#125; if(h &lt; high) &#123; quickSort(arr, l+1, high); &#125; &#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[阿里笔试-着色问题]]></title>
    <url>%2F2018%2F06%2F09%2F%E9%98%BF%E9%87%8C%E7%BC%96%E7%A8%8B%E9%A2%98%2F</url>
    <content type="text"><![CDATA[题目描述将一个圆分为N个扇形，使用M个颜色对这些扇形进行填充，相邻扇形的颜色不能相同，问：有多少种填充方式例如：若N=3，M=3，则有6种方式。样例输入：5 5样例输出：1020 算法思路思路：用递归比较好解决。设最终状态为f(n, m), 一共有两种情况到达最终状态：填最后一个扇形时，它的相邻两个扇形颜色一样和不一样。不一样时，可用颜色为m-2，从状态f(n, m-1)到达；一样时，可用颜色m-1,从状态f(n, m-2)到达.递推数列：f(n,m) = (m-2)f(n, m-1) + (m-1)f(n, m-2)初值：f(n, 1) = n; f(n, 2) = n(n-1); f(n, 3) = n(n-1)*(n-2) 递归实现12345678910111213141516171819202122public class Demo01 &#123; public static int f(int n, int m) &#123; if(n == 1) &#123; return m; &#125; if(n == 2) &#123; return m*(m-1); &#125; if(n == 3) &#123; return m*(m-1)*(m-2); &#125; return (m-2)*f(n-1, m) + (m-1)*f(n-2, m); //f(n, m) = (m-2)*f(n-1, m) + (m-2)*f(n-2, m) &#125; //n-1个扇形时，相邻的两个扇形颜色必定不同，因此是m-2 public static void main(String [] args) &#123; //n-2个扇形时，相邻的两个扇形颜色可以不同，因此是m-1 Scanner sc = new Scanner(System.in); int n = sc.nextInt(); // 扇形个数 int m = sc.nextInt(); // 颜色数目 sc.close(); int num = f(n, m); System.out.println(num); &#125;&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯法思想]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[子集树与排列树当所给问题是从n个元素的集合S中找出满足某种性质的子集时，解空间为子集树。例如：0-1背包问题 (选或不选问题)当所给问题是从n个元素的集合S中找出满足某种性质的排列时，解空间为排列树。例如：旅行售货员问题（选择顺序问题） 算法结构 深度优先搜索与广度优先搜索算法有何区别深度优先搜索法不全部保留结点，扩展完的结点从数据存储结构栈中弹出删去，在栈中存储的结点数就是解空间树的深度，因此它占用空间较少。所以，当搜索树的结点较多，用其它方法易产生内存溢出时，深度优先搜索不失为一种有效的求解方法。广度优先搜索算法，一般需存储产生所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题。但广度优先搜索法一般无回溯操作（即入栈和出栈的操作），所以运行速度比深度优先搜索要快些。 回溯与分支限界区别回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。它们在问题的解空间树T上搜索的方法不同，适合解决的问题也就不同。一般情况下，回溯法的求解目标是找出T中满足约束条件的所有解的方案，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。相对而言，分支限界算法的解空间比回溯法大得多，因此当内存容量有限时，回溯法成功的可能性更大。 最优化处理问题在处理最优问题时，采用穷举法、回溯法或分支限界法都可以通过利用当前最优解和上界函数加速。仅就对限界剪支的效率而言，优先队列的分支限界法显然要更充分一些。在穷举法中通过上界函数与当前情况下函数值的比较可以直接略过不合要求的情况而省去了更进一步的枚举和判断；回溯法则因为层次的划分，可以在上界函数值小于当前最优解时，剪去以该结点为根的子树，也就是节省了搜索范围；分支限界法在这方面除了可以做到回溯法能做到的之外，同时若采用优先队列的分支限界法，用上界函数作为活结点的优先级，一旦有叶结点成为当前扩展结点，就意味着该叶结点所对应的解即为最优解，可以立即终止其余的过程。在前面的例题中曾说明，优先队列的分支限界法更象是有选择、有目的地进行搜索，时间效率、空间效率都是比较高的。 算法总结一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！每个阶段只有一个状态-&gt;递推；每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。 动态规划1.求最优解问题2.整体问题的最优解依赖于各个子问题的最优解3.把大问题分解成小问题，小问题之间还有相互重叠的更小的子问题4.从上往下分析，从下往上求解，避免重复求解小问题]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分糖果]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%88%86%E7%B3%96%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[题目描述 分糖果：科大讯飞第二道编程题 小明和小红是好朋友，但最近遇到一个棘手的问题，有一盒糖果要分成两份但是每颗糖果质量都不尽相同， 但为了分配的公平每份糖的糖果数量相差不得超过1，在此条件下两份糖果的质量差距尽可能小。 输入一行数，包含一个数n，代表糖果数量，后面一次是n个整数一次表示每个糖果的质量，每个糖果的质量都是1到450 之间的一个整数，每盒最多有20个糖果。 输出：每个样例输出两个数字分别为两堆糖果的质量，如不相同，先小后大。 样例：输入：5 9 6 5 8 7 输出：17 18 算法思想回溯，在数量差值为1的结果中找出最小的质量差 Python实现1234567891011121314151617def divide(candies, num, select, sum, total, index): global min global res if(abs(total-sum*2) &lt; min): res = sum min = abs(total-sum*2) result.append(select) for i in range(len(candies)): if(index == num-1): return3 select.append(candies[index]) sum += candies[index] temp = select.copy() if(len(select) &lt;= int(num/2)+1): index += 1 divide(candies, num, temp, sum, total, index) sum -= select[len(select) - 1] select.remove(select[len(select)-1])]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长公共子串-最长公共子序列]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[最长公共子串 DP实现1234567891011121314151617181920212223242526272829public static int maxSubStr(String str1, String str2) &#123; int result = 0; int index = 0; int len1 = str1.length(); int len2 = str2.length(); int [][] dp = new int [len1][len2]; for(int i = 0; i &lt; len1; ++i) &#123; for(int j = 0; j &lt; len2; ++j) &#123; if(str1.charAt(i) == str2.charAt(j)) &#123; if(i &gt; 0 &amp;&amp; j &gt; 0) &#123; dp[i][j] = dp[i-1][j-1] + 1; // 状态转移 if(dp[i][j] &gt; result) &#123; result = dp[i][j]; index = i; // 记录最大子串的最后一个下标 &#125; // result = result &gt; dp[i][j] ? result : dp[i][j]; &#125;else &#123; dp[i][j] = 1; result = result &gt; dp[i][j] ? result : dp[i][j]; &#125; &#125; &#125; &#125; System.out.println(result); for(int i = index - result + 1; i &lt;= index; i++) &#123; System.out.print(str1.charAt(i) + " "); &#125; return result;&#125; 最长公共子序列####动态规划假设Z=&lt;z1,z2,⋯,zk&gt;是X与Y的LCS， 我们观察到如果Xm=Yn，则Zk=Xm=Yn，有Zk−1是Xm−1与Yn−1的LCS；如果Xm≠Yn，则Zk是Xm与Yn−1的LCS，或者是Xm−1与Yn的LCS。因此，求解LCS的问题则变成递归求解的两个子问题。但是，上述的递归求解的办法中，重复的子问题多，效率低下。改进的办法——用空间换时间，用数组保存中间状态，方便后面的计算。这就是动态规划（DP)的核心思想了。DP求解LCS用二维数组c[i][j]记录串x1x2⋯xi与y1y2⋯yj的LCS长度，则可得到状态转移方程: DP实现1234567891011121314151617181920public static int maxSubSequence(String str1, String str2) &#123; int len1 = str1.length(); int len2 = str2.length(); int [][] dp = new int[len1][len2]; for(int i = 0; i &lt; len1; ++i) &#123; for(int j = 0; j &lt; len2; ++j) &#123; if(i &gt; 0 &amp;&amp; j &gt; 0) &#123; if(str1.charAt(i) == str2.charAt(j)) &#123; dp[i][j] = dp[i-1][j-1] + 1; &#125;else &#123; dp[i][j] = dp[i-1][j] &gt; dp[i][j-1] ? dp[i-1][j] : dp[i][j-1]; &#125; &#125;else if(str1.charAt(i) == str2.charAt(j)) &#123; dp[i][j] = 1; &#125; &#125; &#125; System.out.println(dp[len1 - 1][len2 - 1]); return dp[len1-1][len2-1];&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>回溯</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP-乘积最大子序列]]></title>
    <url>%2F2018%2F06%2F09%2FDP-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97%2F</url>
    <content type="text"><![CDATA[题目描述给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。示例 1:输入: [2,3,-2,4]输出: 6解释: 子数组 [2,3] 有最大乘积 6。 示例 2:输入: [-2,0,-1]输出: 0解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。 算法思路本题是求最大乘积，是最大子段和的变种。最大乘积可以由正数正数和负数负数得到，因此，需要同时记录下最大值和最小值。状态转移方程：dp[i] = max(max,dp[i-1])max = max(maxnum[i],minnum[i],nums[i])min = min(maxnum[i],minnum[i],nums[i])其中，dp[i]表示前i个数中的最大乘积，maxm表示以第i-1个字符结尾的最大乘积,minm表示以第i-1个字符结尾的最小乘积,nums[i]即为第i个数。 DP实现123456789101112131415161718192021class Solution &#123; public int maxProduct(int[] nums) &#123; if(nums.length == 0) return 0; int [] dp = new int [nums.length]; dp[0] = nums[0]; int max = nums[0]; int min = nums[0]; for(int i = 1; i &lt; nums.length; i++)&#123; if(nums[i] &gt;= 0)&#123; max = Math.max(nums[i], max*nums[i]); min = Math.min(nums[i], min*nums[i]); &#125;else&#123; int temp = max; max = Math.max(nums[i], min*nums[i]); min = Math.min(nums[i], temp*nums[i]); &#125; dp[i] = Math.max(max, dp[i-1]); &#125; return dp[nums.length-1]; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[括号生成]]></title>
    <url>%2F2018%2F06%2F09%2FDFS-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90%2F</url>
    <content type="text"><![CDATA[题目描述给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。例如，给出 n = 3，生成结果为：[ “((()))”, “(()())”, “(())()”, “()(())”, “()()()”] 算法思路回溯实现12345678910111213141516171819class Solution &#123; void dfs(List&lt;String&gt; result, String str, int left, int right, int n)&#123; if(left &gt; n || right &gt; n || left &lt; right) return; if(left == n &amp;&amp; right == n)&#123; result.add(str); return; &#125; dfs(result, str+"(", left+1, right, n); dfs(result, str+")", left, right+1, n); &#125; public List&lt;String&gt; generateParenthesis(int n) &#123; int count = 0; List&lt;String&gt; result = new ArrayList(); if(n == 0) return result; String str = ""; dfs(result, str, 0, 0, n); return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP-最大上升子序列LIS]]></title>
    <url>%2F2018%2F06%2F09%2F%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97LIS%2F</url>
    <content type="text"><![CDATA[题目描述给定一个无序的整数数组，找到其中最长上升子序列的长度。示例:输入: [10,9,2,5,3,7,101,18]输出: 4解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。说明:可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。你算法的时间复杂度应该为 O(n2) 。进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗? 算法思路O(n^2)解法，DP实现1234567891011121314151617181920212223242526272829303132class Solution &#123; boolean isP(String s)&#123; int i = 0; int j = s.length()-1; while(i &lt; j)&#123; if(s.charAt(i) != s.charAt(j)) return false; else i++; j--; &#125; return true; &#125; void dfs(List&lt;List&lt;String&gt;&gt; result, String s, List&lt;String&gt; res, int index)&#123; if(index == s.length())&#123; List&lt;String&gt; ress = new ArrayList&lt;String&gt;(res); result.add(ress); return; &#125; for(int i = index; i &lt; s.length(); i++)&#123; if(isP(s.substring(index, i+1)))&#123; res.add(s.substring(index, i+1)); dfs(result, s, res, i+1); res.remove(res.size()-1); &#125; &#125; &#125; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList(); List&lt;String&gt; res = new ArrayList(); dfs(result, s, res, 0); return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP-最长递增子序列的个数]]></title>
    <url>%2F2018%2F06%2F09%2FDP-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0%2F</url>
    <content type="text"><![CDATA[题目描述给定一个未排序的整数数组，找到最长递增子序列的个数。示例 1:输入: [1,3,5,4,7]输出: 2解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。 示例 2:输入: [2,2,2,2,2]输出: 5解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。 注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。 算法思路O(n^2)解法，DP实现12345678910111213141516171819202122232425262728293031cclass Solution &#123; public int findNumberOfLIS(int[] nums) &#123; if(nums.length == 0) return 0; int [] dp = new int [nums.length]; int [] count = new int [nums.length]; for(int i = 0; i &lt; nums.length; i++)&#123; dp[i] = count[i] = 1; &#125; int maxLen = 1; for(int i = 1; i &lt; nums.length; i++)&#123; for(int j = 0; j &lt; i; j++)&#123; if(nums[i] &gt; nums[j])&#123; if(dp[i] &lt; dp[j] + 1)&#123; dp[i] = dp[j] + 1; count[i] = count[j]; &#125;else if(dp[i] == dp[j] + 1)&#123; //统计当前长度子序列可由多少次长序列加1得到 count[i] += count[j]; &#125; &#125; &#125; maxLen = Math.max(maxLen, dp[i]); // System.out.println(count[i] + " " + dp[i]); &#125; int res = 0; for(int i = 0; i &lt; count.length; i++)&#123; // 考虑重复情况 if(dp[i] == maxLen) res += count[i]; &#125; return count[nums.length-1]; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[回溯-分割回文串]]></title>
    <url>%2F2018%2F06%2F09%2F%E5%9B%9E%E6%BA%AF-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。返回 s 所有可能的分割方案。示例:输入: “aab”输出:[ [“aa”,”b”], [“a”,”a”,”b”]] 算法思路回溯实现1234567891011121314151617181920212223242526272829303132class Solution &#123; boolean isP(String s)&#123; int i = 0; int j = s.length()-1; while(i &lt; j)&#123; if(s.charAt(i) != s.charAt(j)) return false; else i++; j--; &#125; return true; &#125; void dfs(List&lt;List&lt;String&gt;&gt; result, String s, List&lt;String&gt; res, int index)&#123; if(index == s.length())&#123; List&lt;String&gt; ress = new ArrayList&lt;String&gt;(res); result.add(ress); return; &#125; for(int i = index; i &lt; s.length(); i++)&#123; if(isP(s.substring(index, i+1)))&#123; res.add(s.substring(index, i+1)); dfs(result, s, res, i+1); res.remove(res.size()-1); &#125; &#125; &#125; public List&lt;List&lt;String&gt;&gt; partition(String s) &#123; List&lt;List&lt;String&gt;&gt; result = new ArrayList(); List&lt;String&gt; res = new ArrayList(); dfs(result, s, res, 0); return result; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP+回溯-单词拆分 II]]></title>
    <url>%2F2018%2F06%2F09%2FDP%2B%E5%9B%9E%E6%BA%AF-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20II%2F</url>
    <content type="text"><![CDATA[题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。说明：分隔时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。示例 1：输入:s = “catsanddog”wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]输出:[ “cats and dog”, “cat sand dog”] 示例 2：输入:s = “pineapplepenapple”wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]输出:[ “pine apple pen apple”, “pineapple pen apple”, “pine applepen apple”]解释: 注意你可以重复使用字典中的单词。 示例 3：输入:s = “catsandog”wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]输出:[] 算法思路这道题类似 Word Break I 判断是否能把字符串拆分为字典里的单词 @LeetCode 只不过要求计算的并不仅仅是是否能拆分，而是要求出所有的拆分方案。因此用递归。但是直接递归做会超时，原因是LeetCode里有几个很长但是无法拆分的情况，所以就先跑一遍Word Break I，先判断能否拆分，然后再进行拆分。 DP实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Solution &#123; boolean isBreak(String s, List&lt;String&gt; wordDict) &#123; boolean[] canBreak = new boolean[s.length()+1]; canBreak[0] = true; for(int i=1; i&lt;=s.length(); i++) &#123; boolean flag = false; for(int j=0; j&lt;i; j++) &#123; if(canBreak[j] &amp;&amp; wordDict.contains(s.substring(j,i))) &#123; flag = true; break; &#125; &#125; canBreak[i] = flag; &#125; return canBreak[s.length()]; &#125; void dfs(String s, List&lt;String&gt; wordDict, String str, int index)&#123; String result = str; //记录字符串状态 int len = s.length(); String tmp = s.substring(index, len); if(wordDict.contains(tmp))&#123; //最后一段存在于字典中，则保存结果 str += tmp; res.add(str); &#125; List&lt;Integer&gt; listIndex = new ArrayList(); List&lt;String&gt; listStr = new ArrayList(); for(int i = index; i &lt; len; i++)&#123; String temp = s.substring(index, i+1); if(wordDict.contains(temp))&#123; listIndex.add(i+1); listStr.add(temp); &#125; &#125; String temp = result; //保存递归前的字符串状态，以便回溯 for(int i = 0; i &lt; listIndex.size(); i++)&#123; result += listStr.get(i) + " "; dfs(s, wordDict, result, listIndex.get(i)); result = temp; &#125; &#125; List&lt;String&gt; res = new ArrayList(); public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123; if(!isBreak(s, wordDict)) return res; String str = ""; dfs(s, wordDict, str, 0); return res; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>回溯</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP-单词拆分 I]]></title>
    <url>%2F2018%2F06%2F09%2FDP-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20I%2F</url>
    <content type="text"><![CDATA[题目描述给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。说明：拆分时可以重复使用字典中的单词。你可以假设字典中没有重复的单词。示例 1：输入: s = “leetcode”, wordDict = [“leet”, “code”]输出: true解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。 示例 2：输入: s = “applepenapple”, wordDict = [“apple”, “pen”]输出: true解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。 注意你可以重复使用字典中的单词。 示例 3：输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]输出: false 算法思路动态规划的思路：将问题拆分成更小的子问题。用dp[i]表示0到i的子字符串是否可以拆分成满足条件的单词，在计算dp[i]的时候，我们已经知道dp[0],dp[1],…,dp[i-1],如果以i为结尾的j~i子串是满足条件的，并且0~j的子串也是在字典中的，那么dp[i]就是true。用公式表示就是： dp[j]&amp;&amp;s.substring[j,i+1]∈dict DP实现123456789101112131415class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;; boolean [] dp = new boolean[s.length()+1]； dp[0] = true; for(int i = 0; i &lt; s.length(); i++)&#123; for(int j = 0; j &lt;= i; j++)&#123; if(dp[j] &amp;&amp; wordDict.contains(s.substring(j, i+1)))&#123; dp[i+1] = true; break; &#125; &#125; &#125; return dp[s.length()]; &#125;&#125; DFS解法，超时1234567891011121314151617181920212223242526class Solution &#123; boolean dfs(String s, List&lt;String&gt; wordDict, int index)&#123; // 超时 String left = s.substring(index, s.length()); if(wordDict.contains(left))&#123; return true; &#125; List&lt;Integer&gt; list = new ArrayList(); for(int i = index; i &lt; s.length(); i++)&#123; String temp = s.substring(index, i+1); if(wordDict.contains(temp))&#123; list.add(i+1); &#125; &#125; for(Integer each:list) &#123; if(dfs(s, wordDict, each))&#123; return true; &#125; &#125; return false; &#125; boolean flag = false; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; return dfs(s, wordDict, 0); &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DP-最长回文子串]]></title>
    <url>%2F2018%2F06%2F09%2FDP-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[题目描述给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。示例 1：输入: “babad”输出: “bab”注意: “aba”也是一个有效答案。 示例 2：输入: “cbbd”输出: “bb” 算法思路对称轴法：以枚举的元素为中心扩展，保存最大长度动态规划：用二维数组dp[i][j]记录从i到j的字符串是否是回文串,若是回文串且大于当前最大长度，则更新最大长度。DP状态转移方程：dp[i][j] = dp[i-1][j-1] &amp;&amp; (str[i] == str[j] || i-j &lt;= 1) 正向DP12345678910111213141516public String longestPalindrome(String s) &#123; int len = s.length(); boolean [][] dp = new boolean [len+1][len+1]; String longStr = ""; for(int i = 1; i &lt;= len; i++)&#123; for(int j = i; j &gt;= 1; j--)&#123; if(s.charAt(i-1) == s.charAt(j-1) &amp;&amp; (i-j&lt;=1 || dp[i-1][j+1]))&#123; dp[i][j] = true; if(longStr.length() &lt; s.substring(j-1, i).length())&#123; longStr = s.substring(j-1, i); &#125; &#125; &#125; &#125; return longStr; &#125; 对称轴法12345678910111213141516171819202122public String longestPalindrome(String s) &#123; int len = s.length(); if(len == 0) return ""; String longStr = s.substring(0, 1); for(int i = 0; i &lt; len; i++)&#123; int j = 1; boolean flag1 = true, flag2 = true; while(i-j &gt;=0)&#123; if(flag1 &amp;&amp; i+j &lt;= len-1)&#123; // 以当前i位置元素为中心扩展(奇数情况) if(s.charAt(i-j) == s.charAt(i+j) &amp;&amp; s.substring(i-j, i+j+1).length() &gt; longStr.length())&#123; longStr = s.substring(i-j, i+j+1); &#125;else if(s.charAt(i-j) != s.charAt(i+j)) flag1 = false; &#125; if(flag2 &amp;&amp; i+j &lt;= len)&#123; // 以i-1和i为中心扩展(偶数情况) if(s.charAt(i-j) == s.charAt(i+j-1) &amp;&amp; s.substring(i-j, i+j).length() &gt; longStr.length())&#123; longStr = s.substring(i-j, i+j); &#125;else if(s.charAt(i-j) != s.charAt(i+j-1)) flag2 = false; &#125; j++; &#125; &#125; return longStr;&#125; 逆向DP12345678910111213141516171819class Solution &#123; public String longestPalindrome(String s) &#123; int len = s.length(); boolean [][] dp = new boolean [len+1][len+1]; String longStr = ""; for(int i = len-1; i &gt;= 0; i--)&#123; dp[i][i] = true; for(int j = i; j &lt; len; j++)&#123; if(s.charAt(i) == s.charAt(j) &amp;&amp; (j-i&lt;=1 || dp[i+1][j-1]))&#123; dp[i][j] = true; if(longStr.length() &lt; s.substring(i, j+1).length())&#123; longStr = s.substring(i, j+1); &#125; &#125; &#125; &#125; return longStr; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
