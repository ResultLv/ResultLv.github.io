<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>链表算法题</title>
      <link href="/2018/06/28/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E9%A2%98/"/>
      <url>/2018/06/28/%E9%93%BE%E8%A1%A8%E7%AE%97%E6%B3%95%E9%A2%98/</url>
      <content type="html"><![CDATA[<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单链表节点定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">   <span class="keyword">int</span> val;</span><br><span class="line">   ListNode next;</span><br><span class="line">   ListNode(<span class="keyword">int</span> x) &#123; val = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="删除链表中的节点"><a href="#删除链表中的节点" class="headerlink" title="删除链表中的节点"></a>删除链表中的节点</h3><p>删除链表中等于给定值 val 的所有节点。</p><p>示例:<br>输入: 1-&gt;2-&gt;6-&gt;3-&gt;4-&gt;5-&gt;6, val = 6<br>输出: 1-&gt;2-&gt;3-&gt;4-&gt;5</p><p><strong>注意：该题中头节点也可存值</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常规解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span> &amp;&amp; head.val == val)&#123;    <span class="comment">// 找到第一个值不为val的节点作为头结点</span></span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode q = head, p = head.next;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.val == val)&#123;</span><br><span class="line">                q.next = p.next;</span><br><span class="line">                p = q.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                q = p;</span><br><span class="line">                p = p.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 大佬解法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeElements</span><span class="params">(ListNode head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        head.next = removeElements(head.next, val);</span><br><span class="line">        <span class="keyword">return</span> head.val == val ? head.next : head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表中的节点2"><a href="#删除链表中的节点2" class="headerlink" title="删除链表中的节点2"></a>删除链表中的节点2</h3><p>请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</p><p>示例 1:<br>输入: head = [4,5,1,9], node = 5<br>输出: [4,1,9]<br>解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</p><p><strong>说明:</strong></p><ul><li>链表至少包含两个节点。</li><li>链表中所有节点的值都是唯一的。</li><li>给定的节点为非末尾节点并且一定是链表中的一个有效节点。</li><li>不要从你的函数中返回任何结果。</li></ul><h4 id="可以把要删除的节点，用该节点的后面节点进行覆盖，然后删掉后面那个节点"><a href="#可以把要删除的节点，用该节点的后面节点进行覆盖，然后删掉后面那个节点" class="headerlink" title="可以把要删除的节点，用该节点的后面节点进行覆盖，然后删掉后面那个节点"></a>可以把要删除的节点，用该节点的后面节点进行覆盖，然后删掉后面那个节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除链表中倒数第n个节点"><a href="#删除链表中倒数第n个节点" class="headerlink" title="删除链表中倒数第n个节点"></a>删除链表中倒数第n个节点</h3><p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p><p>示例：<br>给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.<br>当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.<br>说明：<br>给定的 n 保证是有效的。</p><h4 id="一趟扫描实现"><a href="#一趟扫描实现" class="headerlink" title="一趟扫描实现"></a>一趟扫描实现</h4><p><strong>用空间换时间,用一个List存储链表中遍历的所有节点，找到倒数第n个节点并删除</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = list.size();</span><br><span class="line">        <span class="keyword">if</span>(n == len) <span class="keyword">return</span> list.get(<span class="number">1</span>);<span class="comment">// 删除第一个节点</span></span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>) list.get(len-<span class="number">2</span>).next = <span class="keyword">null</span>;<span class="comment">//删除最后一个节点</span></span><br><span class="line">        <span class="keyword">else</span> list.get(len-n-<span class="number">1</span>).next = list.get(len-n+<span class="number">1</span>);<span class="comment">// 删除中间节点</span></span><br><span class="line">        <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="双指针法"><a href="#双指针法" class="headerlink" title="双指针法"></a>双指针法</h4><p>因为是删除倒数第n个节点，假设链表长度为len，那么就是正数第len-n+1个节点，删除要找到要删除节点的前一个，即第len-k个节点。设置两个指针i,j  i先走n步，然后j再从头结点出发，从第n步开始i,j同时移动直到i到达尾结点,此时j移动步数为len-k,即找到了要删除的节点的前驱节点<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode i, j;</span><br><span class="line">        i = j = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; n; index++)</span><br><span class="line">            i = i.next;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="keyword">null</span>)&#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            j = j.next;</span><br><span class="line">            i = i.next;</span><br><span class="line">        &#125;</span><br><span class="line">        j.next = j.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>示例:<br>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL<br>输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><h4 id="我的解法-需额外节点长度存储空间"><a href="#我的解法-需额外节点长度存储空间" class="headerlink" title="我的解法(需额外节点长度存储空间)"></a>我的解法(需额外节点长度存储空间)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        List&lt;ListNode&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            list.add(head);</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = list.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            list.get(len-i).next = list.get(len-i-<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        list.get(<span class="number">0</span>).next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> list.get(len-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常规迭代解法-头插法"><a href="#常规迭代解法-头插法" class="headerlink" title="常规迭代解法(头插法)"></a>常规迭代解法(头插法)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode tail = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(head != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nextNode = head.next;<span class="comment">// 保留下个节点</span></span><br><span class="line">            head.next = tail;<span class="comment">// 当前节点指向反转后链表</span></span><br><span class="line">            tail = head;<span class="comment">// 反转链表头结点替换为当前节点</span></span><br><span class="line">            head = nextNode;<span class="comment">// 转到下个节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>头插法图解</strong><br><img src="https://upload-images.jianshu.io/upload_images/12653638-766f7425e56cd13a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h4 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>||head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;   <span class="comment">// 递归出口，当前为最后一个节点</span></span><br><span class="line">        ListNode tail = reverseList(head.next); <span class="comment">// 反转后的头结点</span></span><br><span class="line">        head.next.next = head;<span class="comment">//反向连接(当前节点的下个节点指向当前节点)</span></span><br><span class="line">        head.next = <span class="keyword">null</span>;<span class="comment">// 断开正向连接</span></span><br><span class="line">        <span class="keyword">return</span> tail;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图解如下：</strong><br><img src="https://upload-images.jianshu.io/upload_images/12653638-9ef3a9d838ed45e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试题19：正则表达式匹配</title>
      <link href="/2018/06/28/%E9%9D%A2%E8%AF%95%E9%A2%9819%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
      <url>/2018/06/28/%E9%9D%A2%E8%AF%95%E9%A2%9819%EF%BC%9A%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
      <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个字符串 (s) 和一个字符模式 (p)。实现支持 ‘.’ 和 ‘*‘ 的正则表达式匹配。</p><ul><li>‘.’ 匹配任意单个字符。</li><li>‘*’ 匹配零个或多个前面的元素。</li><li>匹配应该覆盖整个字符串 (s) ，而不是部分字符串。</li></ul><p>说明:<br>s 可能为空，且只包含从 a-z 的小写字母。<br>p 可能为空，且只包含从 a-z 的小写字母，以及字符 . 和 *。</p><a id="more"></a><p>示例 1:<br>输入:<br>s = “aaa”<br>p = “a*“<br>输出: true<br>解释: “*“ 代表可匹配零个或多个前面的元素, 即可以匹配 ‘a’ 。因此, 重复 ‘a’ 两次, 字符串可变为 “aaa”。</p><p>示例 2:<br>输入:<br>s = “abcd”<br>p = “.*“<br>输出: true<br>解释: “.*“ 表示可匹配零个或多个(‘*‘)任意字符(‘.’)。</p><p>示例 3:<br>输入:<br>s = “aab”<br>p = “c*a*b”<br>输出: true<br>解释: ‘c’ 可以不被匹配, ‘a’ 可以被重复一次。因此可以匹配字符串 “aab”。</p><p>示例 5:<br>输入:<br>s = “mississippi”<br>p = “mis*is*p*.”<br>输出: false</p><h3 id="递归解法-常规版"><a href="#递归解法-常规版" class="headerlink" title="递归解法(常规版)"></a>递归解法(常规版)</h3><p>给字符串和pattern各自设置下标，分两种情况进行匹配，一种是pattern的下一个字符为星号，一种是不为星号,同时考虑为空的边界情况。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(String s, String p, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s.length() &amp;&amp; j == p.length()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(i != s.length() &amp;&amp; j == p.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(j + <span class="number">1</span> &lt; p.length() &amp;&amp; p.charAt(j+<span class="number">1</span>) == <span class="string">'*'</span>)&#123;   <span class="comment">//如果模式串下个字符为*</span></span><br><span class="line">            <span class="keyword">if</span>(i == s.length()) <span class="keyword">return</span> match(s, p, i, j+<span class="number">2</span>); <span class="comment">// 字符串匹配到最后一位，结束当前模式字符*</span></span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">'.'</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> match(s, p, i+<span class="number">1</span>, j) || match(s, p, i, j+<span class="number">2</span>);  <span class="comment">// 匹配下一个字符或者抛弃这个星号去匹配下一个模式</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> match(s, p, i, j+<span class="number">2</span>);     <span class="comment">//直接放弃当前*号</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i == s.length() &amp;&amp; j != p.length()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(i) == p.charAt(j) || p.charAt(j) == <span class="string">'.'</span>)&#123;   <span class="comment">//字符串单个字符与模式串单个字符或.匹配</span></span><br><span class="line">            <span class="keyword">return</span> match(s, p, i+<span class="number">1</span>, j+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.equals(p)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(p.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> match(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>使用二维$dp$数组存放匹配状态，$S[]$为字符串字符数组,$P[]$为模式串字符数组，状态转移共有以下三种情况：</p><ol><li>$S[i] == P[j]$ -&gt; $dp[i][j] = dp[i-1][j-1]$</li><li>$P[j] == ‘.’$ -&gt; $dp[i][j] = dp[i-1][j-1]$</li><li>$P[j] == ‘*’$ -&gt; 还需分两种情况:<ul><li>$S[i] != P[j]$ -&gt; $dp[i][j] = dp[i][j-2]$</li><li>$S[i] == P[j]$:<ul><li>$dp[i][j] = dp[i-1][j]$ a*作为多个a</li><li>$dp[i][j] = dp[i][j-2]$ a*作为空</li></ul></li></ul></li></ol><h4 id="初始化边界条件版-常规"><a href="#初始化边界条件版-常规" class="headerlink" title="初始化边界条件版(常规)"></a>初始化边界条件版(常规)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> col = s.length();</span><br><span class="line">        <span class="keyword">int</span> row = p.length();</span><br><span class="line">        <span class="comment">//建立一个boolean数组，数组长度为 row + 1 * col + 1，多的一列一行代表空串的情况</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[row+<span class="number">1</span>][col+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//第一行剩余元素全部变为false，因为pattern如果是空串，那么只要s不是空串，都不能匹配</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=col;i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//初始化第0列，此时s是空串，所以只能是x*y*这种形式的</span></span><br><span class="line">        <span class="comment">//注意，j-1代表的真实的p的索引</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=row;j++)</span><br><span class="line">            dp[j][<span class="number">0</span>] = (j&gt;<span class="number">1</span>) &amp;&amp; (p.charAt(j-<span class="number">1</span>)==<span class="string">'*'</span>) &amp;&amp; dp[j-<span class="number">2</span>][<span class="number">0</span>];      </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//主体循环开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=col;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=row;j++)&#123;</span><br><span class="line">                <span class="comment">//如果当前的pattern字符串是*，需要同时满足下面的两个条件，才能为true，此时s其实是固定住的，在思考的时候可以这么想</span></span><br><span class="line">                <span class="comment">//1、如果往前数两行的位置可以匹配，那么这里的*可以代表空，此时可以匹配，</span></span><br><span class="line">                <span class="comment">//如果s是aa，p是a*的话，我们不能根据往前数两行来判断，这时必须满足p[j-2]==s[i-1] 或者说 p[j-2]是'.'</span></span><br><span class="line">                <span class="keyword">if</span>(p.charAt(j-<span class="number">1</span>)==<span class="string">'*'</span>)</span><br><span class="line">                    dp[j][i] = dp[j-<span class="number">2</span>][i] || (p.charAt(j-<span class="number">2</span>)==s.charAt(i-<span class="number">1</span>) || p.charAt(j-<span class="number">2</span>)==<span class="string">'.'</span>) &amp;&amp; dp[j][i-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    dp[j][i] = (p.charAt(j-<span class="number">1</span>)==<span class="string">'.'</span> || p.charAt(j-<span class="number">1</span>)==s.charAt(i-<span class="number">1</span>)) &amp;&amp; dp[j-<span class="number">1</span>][i-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="边界条件融入循环-大佬版"><a href="#边界条件融入循环-大佬版" class="headerlink" title="边界条件融入循环(大佬版)"></a>边界条件融入循环(大佬版)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = s.length(), m = p.length();</span><br><span class="line">        <span class="keyword">char</span>[] S = s.toCharArray(), P = p.toCharArray();</span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>][m+<span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; P[j - <span class="number">1</span>] == <span class="string">'*'</span>) &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">2</span>] || (i &gt; <span class="number">0</span> &amp;&amp; (S[i - <span class="number">1</span>] == P[j - <span class="number">2</span>] || P[j - <span class="number">2</span>] == <span class="string">'.'</span>) &amp;&amp; dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = i &gt; <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j - <span class="number">1</span>] &amp;&amp; (S[i - <span class="number">1</span>] == P[j - <span class="number">1</span>] || P[j - <span class="number">1</span>] == <span class="string">'.'</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SVD分解和应用</title>
      <link href="/2018/06/27/SVD%E5%88%86%E8%A7%A3%E5%92%8C%E5%BA%94%E7%94%A8/"/>
      <url>/2018/06/27/SVD%E5%88%86%E8%A7%A3%E5%92%8C%E5%BA%94%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><a href="http://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html" target="_blank" rel="noopener"><strong>奇异值分解详解</strong></a></p><h3 id="奇异值"><a href="#奇异值" class="headerlink" title="奇异值"></a>奇异值</h3><p>奇异值是矩阵里的概念，一般通过奇异值分解定理求得。设$A$为$m*n$阶矩阵，$q=min(m,n)$，$A*A$的$q$个非负特征值的算术平方根叫作$A$的奇异值。</p><h3 id="奇异值分解"><a href="#奇异值分解" class="headerlink" title="奇异值分解"></a>奇异值分解</h3><p><strong>奇异值分解是一个能适用于任意的矩阵的一种分解的方法</strong><br><img src="https://upload-images.jianshu.io/upload_images/12653638-64a8ad70474e2a53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><a id="more"></a><br>假设A是一个$N*M$的矩阵，那么得到的U是一个$N*N$的方阵（里面的向量是正交的，$U$里面的向量称为左奇异向量），$\Sigma$是一个$N*M$的矩阵（除了对角线的元素都是0，对角线上的元素称为奇异值），$V^T$($V$的转置)是一个$N*N$的矩阵，里面的向量也是正交的，$V$里面的向量称为右奇异向量），从图片来反映几个相乘的矩阵的大小:<br><img src="https://upload-images.jianshu.io/upload_images/12653638-c7fcc6bff01547b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>示例</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([[<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">              [<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">              [<span class="number">4</span>, <span class="number">9</span>, <span class="number">3</span>],</span><br><span class="line">              [<span class="number">7</span>, <span class="number">1</span>, <span class="number">4</span>]])</span><br><span class="line"> U, S, V = np.linalg.svd(A)</span><br><span class="line"> S1 = np.zeros(A.shape)</span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">     S1[i][i] = S[i]</span><br><span class="line"> print(U)</span><br><span class="line"> print(S1)</span><br><span class="line"> print(V)</span><br></pre></td></tr></table></figure></p><p><center>U</center><br><img src="https://upload-images.jianshu.io/upload_images/12653638-0e8964f68736279f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><center>S</center><br><img src="https://upload-images.jianshu.io/upload_images/12653638-c52b1012db804e37.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><center>V</center><br><img src="https://upload-images.jianshu.io/upload_images/12653638-95d8ce325ff6d85f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>那么奇异值和特征值是怎么对应起来的呢？首先，$A^T$*$A$，将会得到一个方阵，我们用这个方阵求特征值可以得到：<br><img src="https://upload-images.jianshu.io/upload_images/12653638-afb6c88d63232497.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这里得到的$V$，就是我们上面的右奇异向量。此外我们还可以得到：<br><img src="https://upload-images.jianshu.io/upload_images/12653638-cda37a2f45928431.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>这里的$σ$就是上面说的奇异值，$u$就是上面说的左奇异向量。奇异值$σ$跟特征值类似，在矩阵$Σ$中也是从大到小排列，而且$σ$的减少特别的快，在很多情况下，前10%甚至1%的奇异值的和就占了全部的奇异值之和的99%以上了。也就是说，我们也可以用前$r$大的奇异值来近似描述矩阵，这里定义一下部分奇异值分解：<br><img src="https://upload-images.jianshu.io/upload_images/12653638-13968ee063c3cc7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>$r$是一个远小于$m$、$n$的数，这样矩阵的乘法看起来像是下面的样子：<br><img src="https://upload-images.jianshu.io/upload_images/12653638-426b4c84174cff81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>右边的三个矩阵相乘的结果将会是一个接近于$A$的矩阵，在这儿，$r$越接近于$n$，则相乘的结果越接近于$A$。而这三个矩阵的面积之和（在存储观点来说，矩阵面积越小，存储量就越小）要远远小于原始的矩阵$A$，我们如果想要压缩空间来表示原矩阵$A$，我们存下这里的三个矩阵：$U$、$Σ$、$V$就好了。</p><h3 id="奇异值分解图片"><a href="#奇异值分解图片" class="headerlink" title="奇异值分解图片"></a>奇异值分解图片</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">imageSVD</span><span class="params">(file, percent)</span>:</span></span><br><span class="line">    rgb = plt.imread(file)</span><br><span class="line">    print(rgb.shape)</span><br><span class="line">    r = np.array(rgb[:, :, <span class="number">0</span>])</span><br><span class="line">    g = np.array(rgb[:, :, <span class="number">1</span>])</span><br><span class="line">    b = np.array(rgb[:, :, <span class="number">2</span>])</span><br><span class="line">    u0, s0, v0 = np.linalg.svd(r)</span><br><span class="line">    u1, s1, v1 = np.linalg.svd(g)</span><br><span class="line">    u2, s2, v2 = np.linalg.svd(b)</span><br><span class="line"></span><br><span class="line">    S0 = np.zeros(r.shape)</span><br><span class="line">    S1 = np.zeros(r.shape)</span><br><span class="line">    S2 = np.zeros(r.shape)</span><br><span class="line"></span><br><span class="line">    num = int(min(r.shape[<span class="number">0</span>], r.shape[<span class="number">1</span>]) * percent)</span><br><span class="line">    print(num)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(num):<span class="comment">#取RGB三通道前num个奇异值</span></span><br><span class="line">        S0[i][i] = s0[i]</span><br><span class="line">        S1[i][i] = s1[i]</span><br><span class="line">        S2[i][i] = s2[i]</span><br><span class="line"></span><br><span class="line">    R = np.dot(np.dot(u0[:, :num], S0[:num, :num]), v0[:num, :])</span><br><span class="line">    G = np.dot(np.dot(u1[:, :num], S1[:num, :num]), v1[:num, :])</span><br><span class="line">    B = np.dot(np.dot(u2[:, :num], S2[:num, :num]), v2[:num, :])</span><br><span class="line">    RGB = np.stack((R, G, B), <span class="number">2</span>)<span class="comment">#RGB矩阵堆叠，堆叠后维度(1000, 1000, 3)</span></span><br><span class="line">    RGB[RGB &gt; <span class="number">255</span>] = <span class="number">255</span></span><br><span class="line">    RGB[RGB &lt; <span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    RGB = np.rint(RGB).astype(<span class="string">'uint8'</span>)<span class="comment">#化为最近整形</span></span><br><span class="line">    <span class="keyword">return</span> RGB</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    file = <span class="string">'meizi.jpg'</span></span><br><span class="line">    RGB = plt.imread(file)</span><br><span class="line">    RGB = imageSVD(file, <span class="number">0.1</span>)</span><br><span class="line">    <span class="comment"># plt.imsave('meizi_svd.jpg',RGB)</span></span><br><span class="line">    plt.imshow(RGB)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><strong>原图</strong><br><img src="https://upload-images.jianshu.io/upload_images/12653638-d7869cbac033eef3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>0.1倍奇异值</strong><br><img src="https://upload-images.jianshu.io/upload_images/12653638-c5e9fb20224d1abc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>0.05倍奇异值</strong><br><img src="https://upload-images.jianshu.io/upload_images/12653638-07943b170f409046.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>0.01倍奇异值</strong><br><img src="https://upload-images.jianshu.io/upload_images/12653638-e78948df24477f17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>]]></content>
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> PCA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>面试题17：打印从1到最大的n位数</title>
      <link href="/2018/06/25/%E9%9D%A2%E8%AF%95%E9%A2%9817%EF%BC%9A%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/"/>
      <url>/2018/06/25/%E9%9D%A2%E8%AF%95%E9%A2%9817%EF%BC%9A%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
      <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>输入数字n，按顺序打印出从1到最大的n位十进制数。比如输入3，则打印出1、2、3一直到最大的三位数999</p><hr><p><strong>注意：本题实际考察大数问题，直接循环打印整形会溢出，采用字符串模拟加法</strong><br><a id="more"></a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printToMax</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">char</span> [] nums = <span class="keyword">new</span> <span class="keyword">char</span>[n+<span class="number">1</span>];</span><br><span class="line">Arrays.fill(nums, <span class="string">'0'</span>);</span><br><span class="line"><span class="keyword">while</span>(increase(nums)) &#123;</span><br><span class="line">printNum(nums);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">increase</span><span class="params">(<span class="keyword">char</span>[] nums)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len = nums.length;</span><br><span class="line"><span class="keyword">if</span>(nums[len-<span class="number">1</span>] == <span class="string">'1'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span> takeOver = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(takeOver != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = nums[i] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>((<span class="keyword">char</span>)sum &gt; <span class="string">'9'</span>) &#123;</span><br><span class="line">takeOver = <span class="number">1</span>;</span><br><span class="line">nums[i] = <span class="string">'0'</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">takeOver = <span class="number">0</span>;</span><br><span class="line">nums[i] = (<span class="keyword">char</span>)sum;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printNum</span><span class="params">(<span class="keyword">char</span> [] nums)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">int</span> i = nums.length-<span class="number">2</span>;<span class="comment">//从倒数第二位开始</span></span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">while</span>(i &gt;= <span class="number">0</span>) &#123;<span class="comment">//倒序打印</span></span><br><span class="line"><span class="keyword">if</span>(nums[i] != <span class="string">'0'</span>) flag = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">if</span>(flag) &#123;</span><br><span class="line">str += nums[i];</span><br><span class="line">&#125;</span><br><span class="line">i--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(str == <span class="string">""</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="回溯全排列"><a href="#回溯全排列" class="headerlink" title="回溯全排列"></a>回溯全排列</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>打印从1到最大的n位数其实就是n个0-9的数字的全排列，因而可用回溯法求解<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯全排列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">strDFS</span><span class="params">(String str, <span class="keyword">int</span> n, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span>;<span class="comment">// 处理n小于等于0的情况</span></span><br><span class="line"><span class="keyword">if</span>(index == n) &#123;<span class="comment">// 去除字符串前面多余的0</span></span><br><span class="line"><span class="keyword">int</span> isNot = <span class="number">0</span>;<span class="comment">// 第一个不为0的下标</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(str.charAt(i) != <span class="string">'0'</span>) &#123;</span><br><span class="line">isNot = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">isNot = n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isNot == n) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">else</span> System.out.println(str.substring(isNot, str.length()));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">str += (<span class="keyword">char</span>)(i+<span class="number">48</span>);</span><br><span class="line">strDFS(str, n, index+<span class="number">1</span>);</span><br><span class="line">str = str.substring(<span class="number">0</span>, str.length()-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 面试题 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树深度</title>
      <link href="/2018/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6/"/>
      <url>/2018/06/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6/</url>
      <content type="html"><![CDATA[<h2 id="二叉树最大深度"><a href="#二叉树最大深度" class="headerlink" title="二叉树最大深度"></a>二叉树最大深度</h2><p>给定一个二叉树，找出其最大深度。<br>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。<br>说明: 叶子节点是指没有子节点的节点。</p><p>示例：<br>给定二叉树 [3,9,20,null,null,15,7]，</p><pre><code>  3 / \9  20  /  \ 15   7</code></pre><p>返回它的最大深度3 。<br><a id="more"></a></p><h4 id="DFS实现"><a href="#DFS实现" class="headerlink" title="DFS实现"></a>DFS实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树节点定义.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ldeepth = maxDepth(root.left);</span><br><span class="line">        <span class="keyword">int</span> rdeepth = maxDepth(root.right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(ldeepth, rdeepth) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树最小深度"><a href="#二叉树最小深度" class="headerlink" title="二叉树最小深度"></a>二叉树最小深度</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个二叉树，找出其最小深度。<br>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。<br>说明: 叶子节点是指没有子节点的节点。</p><p>示例:<br>给定二叉树 [3,9,20,null,null,15,7],</p><pre><code>  3 / \9  20  /  \ 15   7</code></pre><p>返回它的最小深度2 。</p><h4 id="DFS实现-1"><a href="#DFS实现-1" class="headerlink" title="DFS实现"></a>DFS实现</h4><p><strong>注意：求最小深度，需要考虑单子树和双子树两种情况，双子树取左右子树中的较小值；单子树取最大深度</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 二叉树节点定义.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> deepth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> &amp;&amp; root.right == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = minDepth(root.left) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = minDepth(root.right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left == <span class="keyword">null</span> || root.right == <span class="keyword">null</span>) deepth = Math.max(l, r);    <span class="comment">// 单子树取最大深度</span></span><br><span class="line">        <span class="keyword">else</span> deepth = Math.min(l, r);   <span class="comment">// 双子树取最小深度</span></span><br><span class="line">        <span class="keyword">return</span> deepth;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 二叉树 </tag>
            
            <tag> DFS </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>矩阵中的最长递增路径</title>
      <link href="/2018/06/22/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/"/>
      <url>/2018/06/22/%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E8%B7%AF%E5%BE%84/</url>
      <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数矩阵，找出最长递增路径的长度。<br>对于每个单元格，你可以往上，下，左，右四个方向移动。 你不能在对角线方向上移动或移动到边界外（即不允许环绕）。</p><p>示例 1:<br>输入: nums =<br>[<br>  [9,9,4],<br>  [6,6,8],<br>  [2,1,1]<br>]<br>输出: 4<br>解释: 最长递增路径为 [1, 2, 6, 9]。</p><a id="more"></a><p>示例 2:<br>输入: nums =<br>[<br>  [3,4,5],<br>  [3,2,6],<br>  [2,2,1]<br>]<br>输出: 4<br>解释: 最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</p><h4 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> [] ro = &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> [] co = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> [][] matrix, List&lt;Integer&gt; path, <span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList(path);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = row + ro[i];</span><br><span class="line">            <span class="keyword">int</span> c = col + co[i];</span><br><span class="line">            <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; r &lt; matrix.length &amp;&amp; c &lt; matrix[<span class="number">0</span>].length &amp;&amp; matrix[r][c] &gt; matrix[row][col])&#123;</span><br><span class="line">                res.add(matrix[r][c]);</span><br><span class="line">                <span class="keyword">if</span>(res.size() &gt; maxLen)&#123;</span><br><span class="line">                    maxLen = res.size();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// System.out.println(res);</span></span><br><span class="line">                dfs(matrix, res, r, c);</span><br><span class="line">                res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.length; i++) &#123;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[i].length; j++) &#123;</span><br><span class="line">                List &lt;Integer&gt; path = <span class="keyword">new</span> ArrayList(); </span><br><span class="line">                path.add(matrix[i][j]);</span><br><span class="line">                dfs(matrix, path, i, j);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态规划-DFS"><a href="#动态规划-DFS" class="headerlink" title="动态规划+DFS"></a>动态规划+DFS</h4><p>这道题给我们一个二维数组，让我们求矩阵中最长的递增路径，规定我们只能上下左右行走，不能走斜线或者是超过了边界。那么这道题的解法要用递归和DP来解，用DP的原因是为了提高效率，避免重复运算。我们需要维护一个二维动态数组dp，其中dp[i][j]表示数组中以(i,j)为起点的最长递增路径的长度，初始将dp数组都赋为0，当我们用递归调用时，遇到某个位置(x, y), 如果dp[x][y]不为0的话，我们直接返回dp[x][y]即可，不需要重复计算。我们需要以数组中每个位置都为起点调用递归来做，比较找出最大值。在以一个位置为起点用DFS搜索时，对其四个相邻位置进行判断，如果相邻位置的值大于上一个位置，则对相邻位置继续调用递归，并更新一个最大值，搜素完成后返回即可，参见代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> [] ro = &#123;-<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> [] co = &#123;<span class="number">0</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> [][] matrix, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> [][] dp)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[row][col] != <span class="number">0</span>) <span class="keyword">return</span> dp[row][col];  <span class="comment">// 递归出口,若已访问则返回该节点的最长递增路径长度</span></span><br><span class="line">        dp[row][col] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> r = row + ro[i];</span><br><span class="line">            <span class="keyword">int</span> c = col + co[i];</span><br><span class="line">            <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; r &lt; matrix.length &amp;&amp; c &lt; matrix[<span class="number">0</span>].length &amp;&amp; matrix[r][c] &gt; matrix[row][col])&#123;</span><br><span class="line">                dp[row][col] = Math.max(dp[row][col], dfs(matrix, r, c, dp)+<span class="number">1</span>); <span class="comment">// 若满足递增条件且不越界则继续寻找下个节点，并更新dp数组</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[row][col];</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix == <span class="keyword">null</span> || matrix.length == <span class="number">0</span> || matrix[<span class="number">0</span>].length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [matrix.length][matrix[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;matrix.length; i++) &#123; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;matrix[i].length; j++) &#123;</span><br><span class="line">                max = Math.max(max, dfs(matrix, i, j, dp));  </span><br><span class="line">            &#125; </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> DFS </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pytorch0.4.0入门教程</title>
      <link href="/2018/06/21/Pytorch0-4-0%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2018/06/21/Pytorch0-4-0%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      <content type="html"><![CDATA[<p>pytorch0.4支持了Windows系统的开发，在<a href="https://pytorch.org/" target="_blank" rel="noopener">首页</a>即可使用pip安装pytorch和torchvision。<br> 说白了，以下文字就是来自<a href="https://pytorch.org/tutorials/beginner/deep_learning_60min_blitz.html" target="_blank" rel="noopener">官方文档60分钟入门的简要翻译</a>.</p><h2 id="pytorch是啥"><a href="#pytorch是啥" class="headerlink" title="pytorch是啥"></a>pytorch是啥</h2><p>python的科学计算库，使得NumPy可用于GPU计算，并提供了一个深度学习平台使得灵活性和速度最大化</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><h4 id="Tensors-张量"><a href="#Tensors-张量" class="headerlink" title="Tensors(张量)"></a>Tensors(张量)</h4><a id="more"></a><p>Tensors与NumPy的ndarrays类似，另外可以使用GPU加速计算</p><p>未初始化的5*3的矩阵:<code>x = torch.empty(5, 3)</code><br> 随机初始化的矩阵:<code>x = torch.rand(5, 3)</code><br> 全零矩阵,定义数据类型:<code>x = torch.zeros(5, 3, dtype=torch.long)</code><br> 由数据构造矩阵:<code>x = torch.tensor([5.5, 3])</code><br> 由已存在张量构造矩阵，性质与之前张量一致:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = x.new_ones(5, 3, dtype=torch.double) </span><br><span class="line">x = torch.randn_like(x, dtype=torch.float)</span><br></pre></td></tr></table></figure><p>获取维度:<code>print(x.size())</code></p><h4 id="Operations"><a href="#Operations" class="headerlink" title="Operations"></a>Operations</h4><p>有多种operation的格式，这里考虑加法</p><ol><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y = torch.rand(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">print(x + y)</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(torch.add(x, y))</span><br></pre></td></tr></table></figure><ol start="3"><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">result = torch.empty(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line">torch.add(x, y, out=result)</span><br><span class="line">print(result)</span><br></pre></td></tr></table></figure><ol start="4"><li></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># adds x to y</span></span><br><span class="line">y.add_(x)</span><br><span class="line">print(y)</span><br></pre></td></tr></table></figure><p>operations中需要改变张量本身的值，可以在operation后加<em>,比如`x.copy</em>(y), x.t_()`</p><p>索引:<code>print(x[:, 1])</code><br> 改变维度:<code>x.view(-1, 8)</code></p><h3 id="和Numpy的联系"><a href="#和Numpy的联系" class="headerlink" title="和Numpy的联系"></a>和Numpy的联系</h3><p>torch tensor 和 numpy array之间可以进行相互转换，他们会共享内存位置，改变一个，另一个会跟着改变。</p><h4 id="tensor-to-array"><a href="#tensor-to-array" class="headerlink" title="tensor to array"></a>tensor to array</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">b = a.numpy()</span><br><span class="line">a.add_(<span class="number">1</span>)</span><br><span class="line">print(a,b)</span><br></pre></td></tr></table></figure><h4 id="array-to-tensor"><a href="#array-to-tensor" class="headerlink" title="array to tensor"></a>array to tensor</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = np.ones(<span class="number">5</span>)</span><br><span class="line">b = torch.from_numpy(a)</span><br><span class="line">np.add(a, <span class="number">1</span>, out=a)</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><h3 id="CUDA-Tensors"><a href="#CUDA-Tensors" class="headerlink" title="CUDA Tensors"></a>CUDA Tensors</h3><p>tensor可以使用<code>.to</code>方法将其移动到任何设备。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># let us run this cell only if CUDA is available</span></span><br><span class="line"><span class="comment"># We will use ``torch.device`` objects to move tensors in and out of GPU</span></span><br><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span><br><span class="line">    device = torch.device(<span class="string">"cuda"</span>)          <span class="comment"># a CUDA device object</span></span><br><span class="line">    y = torch.ones_like(x, device=device)  <span class="comment"># directly create a tensor on GPU</span></span><br><span class="line">    x = x.to(device)                       <span class="comment"># or just use strings ``.to("cuda")``</span></span><br><span class="line">    z = x + y</span><br><span class="line">    print(z)</span><br><span class="line">    print(z.to(<span class="string">"cpu"</span>, torch.double))       <span class="comment"># ``.to`` can also change dtype together!</span></span><br></pre></td></tr></table></figure><h2 id="Autograd-自动求导"><a href="#Autograd-自动求导" class="headerlink" title="Autograd(自动求导)"></a>Autograd(自动求导)</h2><p>pytorch神经网络的核心模块就是autograd，autograd模块对Tensors上的所有operations提供了自动求导。</p><h3 id="Tensor"><a href="#Tensor" class="headerlink" title="Tensor"></a>Tensor</h3><p><code>torch.Tensor</code>是模块中的核心类，如果设置属性<code>.requires_grad = True</code>,开始追踪张量上的所有节点操作，指定其是否计算梯度。使用<code>.backward()</code>方法进行所有梯度的自动求导，张量的梯度会累积到<code>.grad</code>属性中。<br> <code>.detach()</code>停止张量的追踪，从梯度计算中分离出来；另外在评估模型时一般使用代码块<code>with torch.no_grad():</code>,因为模型中通常训练的参数也会有<code>.requires_grad = True</code>,这样写可以停止全部张量的梯度更新。<br> <code>Function</code>类是autograd的变体，<code>Tensor</code>和<code>Function</code>相互交错构建成无环图，编码了完整的计算过程，每个Variable(变量)都有<code>.grad_fn</code>属性，引用一个已经创建了的Tensor的Function.<br> 如上，使用<code>.backward()</code>计算梯度。如果张量是一个标量(只有一个元素),不需要对<code>.backward()</code>指定参数；如果张量不止一个元素，需要指定<code>.backward()</code>的参数，其匹配张量的维度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">x = torch.ones(<span class="number">2</span>, <span class="number">2</span>, requires_grad=<span class="keyword">True</span>)</span><br><span class="line">print(x)</span><br><span class="line">y = x + <span class="number">2</span></span><br><span class="line">print(y)</span><br><span class="line">print(y.grad_fn)</span><br><span class="line">z = y * y * <span class="number">3</span></span><br><span class="line">out = z.mean()</span><br><span class="line">print(z, out)</span><br><span class="line"></span><br><span class="line">a = torch.randn(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">a = ((a * <span class="number">3</span>) / (a - <span class="number">1</span>))</span><br><span class="line">print(a.requires_grad)</span><br><span class="line">a.requires_grad_(<span class="keyword">True</span>) <span class="comment"># 改变a张量内在的属性</span></span><br><span class="line">print(a.requires_grad)</span><br><span class="line">b = (a * a).sum()</span><br><span class="line">print(b.grad_fn)</span><br></pre></td></tr></table></figure><h3 id="Gradients"><a href="#Gradients" class="headerlink" title="Gradients"></a>Gradients</h3><p>反向传播时，由于<code>out</code>是一个标量，<code>out.backward()</code>等效于<code>out.backward(torch.tensor(1))</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">out.backward()</span><br><span class="line">print(x.grad)</span><br><span class="line"></span><br><span class="line">x = torch.randn(<span class="number">3</span>, requires_grad=<span class="keyword">True</span>)</span><br><span class="line"></span><br><span class="line">y = x * <span class="number">2</span></span><br><span class="line"><span class="keyword">while</span> y.data.norm() &lt; <span class="number">1000</span>:</span><br><span class="line">    y = y * <span class="number">2</span></span><br><span class="line"></span><br><span class="line">print(y)</span><br><span class="line"></span><br><span class="line">gradients = torch.tensor([<span class="number">0.1</span>, <span class="number">1.0</span>, <span class="number">0.0001</span>], dtype=torch.float)</span><br><span class="line">y.backward(gradients)</span><br><span class="line"></span><br><span class="line">print(x.grad)</span><br><span class="line"></span><br><span class="line">print(x.requires_grad)</span><br><span class="line">print((x ** <span class="number">2</span>).requires_grad)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> torch.no_grad():</span><br><span class="line">    print((x ** <span class="number">2</span>).requires_grad)</span><br></pre></td></tr></table></figure><h2 id="神经网络"><a href="#神经网络" class="headerlink" title="神经网络"></a>神经网络</h2><p>神经网络可以用<code>torch.nn</code>构建。<code>nn</code>依赖于<code>autograd</code>定义模型和求导，<code>nn.Module</code>定义网络层，方法<code>forward(input)</code>返回网络输出。</p><p>举例说明，如下是对数字图片分类的卷积网络架构。<br><img src="https://upload-images.jianshu.io/upload_images/12654931-fb68bfe5f7c4d22e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br> 这是一个简单的前馈神经网络，将输入数据依次通过几层网络层后最终得到输出。<br> 神经网络典型的训练步骤如下：</p><ul><li>定义神经网络及学习的参数(权重)</li><li>迭代输入数据</li><li>将输入数据输入到网络结构中</li><li>计算代价函数</li><li>误差向后传播</li><li>更新网络权重 <code>weight = weight - learning_rate * gradient</code> </li></ul><h3 id="定义网络"><a href="#定义网络" class="headerlink" title="定义网络"></a>定义网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span><br><span class="line"><span class="keyword">import</span> torch.nn.functional <span class="keyword">as</span> F</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Net</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        super(Net, self).__init__()</span><br><span class="line">        <span class="comment"># 1 input image channel, 6 output channels, 5x5 square convolution</span></span><br><span class="line">        <span class="comment"># kernel</span></span><br><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">6</span>, <span class="number">5</span>)</span><br><span class="line">        self.conv2 = nn.Conv2d(<span class="number">6</span>, <span class="number">16</span>, <span class="number">5</span>)</span><br><span class="line">        <span class="comment"># an affine operation: y = Wx + b</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">16</span> * <span class="number">5</span> * <span class="number">5</span>, <span class="number">120</span>)</span><br><span class="line">        self.fc2 = nn.Linear(<span class="number">120</span>, <span class="number">84</span>)</span><br><span class="line">        self.fc3 = nn.Linear(<span class="number">84</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        <span class="comment"># Max pooling over a (2, 2) window</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv1(x)), (<span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line">        <span class="comment"># If the size is a square you can only specify a single number</span></span><br><span class="line">        x = F.max_pool2d(F.relu(self.conv2(x)), <span class="number">2</span>)</span><br><span class="line">        x = x.view(<span class="number">-1</span>, self.num_flat_features(x))</span><br><span class="line">        x = F.relu(self.fc1(x))</span><br><span class="line">        x = F.relu(self.fc2(x))</span><br><span class="line">        x = self.fc3(x)</span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">num_flat_features</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        size = x.size()[<span class="number">1</span>:]  <span class="comment"># all dimensions except the batch dimension</span></span><br><span class="line">        num_features = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> size:</span><br><span class="line">            num_features *= s</span><br><span class="line">        <span class="keyword">return</span> num_features</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">net = Net()</span><br><span class="line">print(net)</span><br></pre></td></tr></table></figure><p>out:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Net(</span><br><span class="line">  (conv1): Conv2d(<span class="number">1</span>, <span class="number">6</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (conv2): Conv2d(<span class="number">6</span>, <span class="number">16</span>, kernel_size=(<span class="number">5</span>, <span class="number">5</span>), stride=(<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">  (fc1): Linear(in_features=<span class="number">400</span>, out_features=<span class="number">120</span>, bias=<span class="keyword">True</span>)</span><br><span class="line">  (fc2): Linear(in_features=<span class="number">120</span>, out_features=<span class="number">84</span>, bias=<span class="keyword">True</span>)</span><br><span class="line">  (fc3): Linear(in_features=<span class="number">84</span>, out_features=<span class="number">10</span>, bias=<span class="keyword">True</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>可以仅定义<code>forward()</code>函数，当使用<code>autograd</code>时<code>backward()</code>被自动定义。可以在<code>forward()</code>函数中使用任何operation操作。<br> <code>net.parameters()</code>返回模型中的可学习参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">params = list(net.parameters())</span><br><span class="line">print(len(params))</span><br><span class="line">print(params[<span class="number">0</span>].size())  <span class="comment"># conv1's .weight</span></span><br></pre></td></tr></table></figure><p>使所有参数的梯度归零然后开始计算梯度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">net.zero_grad()</span><br><span class="line">out.backward(torch.randn(<span class="number">1</span>, <span class="number">10</span>))</span><br></pre></td></tr></table></figure><h3 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h3><p>代价函数将(output,target)作为输入，计算output与target之间的距离。<br> nn模块中有几种不同的代价函数选择，最简单的是<code>nn.MSELoss</code>，计算均方误差<br> eg：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">output = net(input)</span><br><span class="line">target = torch.arange(<span class="number">1</span>, <span class="number">11</span>)  <span class="comment"># a dummy target, for example</span></span><br><span class="line">target = target.view(<span class="number">1</span>, <span class="number">-1</span>)  <span class="comment"># make it the same shape as output</span></span><br><span class="line">criterion = nn.MSELoss()</span><br><span class="line"></span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">print(loss)</span><br></pre></td></tr></table></figure><p>按照向后传播的方向传播loss，使用<code>grad_fn</code>可以查看整个流程的计算图</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">input -&gt; conv2d -&gt; relu -&gt; maxpool2d -&gt; conv2d -&gt; relu -&gt; maxpool2d</span><br><span class="line">      -&gt; view -&gt; linear -&gt; relu -&gt; linear -&gt; relu -&gt; linear</span><br><span class="line">      -&gt; MSELoss</span><br><span class="line">      -&gt; loss</span><br></pre></td></tr></table></figure><p>使用<code>loss.backward()</code>，流程中所有<code>requres_grad=True</code>的张量累积它的梯度至<code>.grad</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(loss.grad_fn)  <span class="comment"># MSELoss</span></span><br><span class="line">print(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>])  <span class="comment"># Linear</span></span><br><span class="line">print(loss.grad_fn.next_functions[<span class="number">0</span>][<span class="number">0</span>].next_functions[<span class="number">0</span>][<span class="number">0</span>])  <span class="comment"># ReLU</span></span><br></pre></td></tr></table></figure><h3 id="向后传播"><a href="#向后传播" class="headerlink" title="向后传播"></a>向后传播</h3><p><code>loss.backward()</code>传播误差，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">net.zero_grad()     <span class="comment"># zeroes the gradient buffers of all parameters</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'conv1.bias.grad before backward'</span>)</span><br><span class="line">print(net.conv1.bias.grad)</span><br><span class="line"></span><br><span class="line">loss.backward()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'conv1.bias.grad after backward'</span>)</span><br><span class="line">print(net.conv1.bias.grad)</span><br></pre></td></tr></table></figure><h3 id="更新权重"><a href="#更新权重" class="headerlink" title="更新权重"></a>更新权重</h3><p>误差每次传播后，需要对权重进行更新，简单的更新方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">learning_rate = <span class="number">0.01</span></span><br><span class="line"><span class="keyword">for</span> f <span class="keyword">in</span> net.parameters():</span><br><span class="line">    f.data.sub_(f.grad.data * learning_rate)</span><br></pre></td></tr></table></figure><p><code>torch.optim</code>实现了这一过程，并有着不同的更新规则GD, Nesterov-SGD, Adam, RMSProp，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.optim <span class="keyword">as</span> optim</span><br><span class="line"></span><br><span class="line"><span class="comment"># create your optimizer</span></span><br><span class="line">optimizer = optim.SGD(net.parameters(), lr=<span class="number">0.01</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># in your training loop:</span></span><br><span class="line">optimizer.zero_grad()   <span class="comment"># zero the gradient buffers</span></span><br><span class="line">output = net(input)</span><br><span class="line">loss = criterion(output, target)</span><br><span class="line">loss.backward()</span><br><span class="line">optimizer.step()    <span class="comment"># Does the update</span></span><br></pre></td></tr></table></figure><p>note: 每次迭代时由于梯度的累积，需要手动将梯度归零<code>optimizer.zero_grad()</code></p>]]></content>
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> 深度学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Pytorch0.4.0更新</title>
      <link href="/2018/06/21/Pytorch0.4.0%E6%9B%B4%E6%96%B0/"/>
      <url>/2018/06/21/Pytorch0.4.0%E6%9B%B4%E6%96%B0/</url>
      <content type="html"><![CDATA[<h3 id="一、重大核心变化包括"><a href="#一、重大核心变化包括" class="headerlink" title="一、重大核心变化包括"></a>一、重大核心变化包括</h3><ul><li>Tensor/Variable 合并</li><li>零维张量</li><li>数据类型</li><li>迁移指南</li></ul><h3 id="二、现添加的新特征包括"><a href="#二、现添加的新特征包括" class="headerlink" title="二、现添加的新特征包括"></a>二、现添加的新特征包括</h3><ul><li>Tensors：</li><li>全面支持高级索引</li><li>快速傅立叶变换</li><li>神经网络：</li><li>计算时的存储权衡</li><li>bottleneck-识别代码中热点（hotspots）的工具</li><li>torch.distributions</li><li>24 个基础的概率分布</li><li>增加cdf、方差、信息熵、困惑度等</li><li>分布式训练<a id="more"></a></li><li>易于使用的 Launcher utility</li><li>NCCL2 后端</li><li>C++拓展</li><li>Windows 支持</li><li>ONNX 改进</li><li>RNN 支持</li></ul><h3 id="三、性能改进"><a href="#三、性能改进" class="headerlink" title="三、性能改进"></a>三、性能改进</h3><h3 id="四、Bug-修复"><a href="#四、Bug-修复" class="headerlink" title="四、Bug 修复"></a>四、Bug 修复</h3><h3 id="五、torchvision的一些变化"><a href="#五、torchvision的一些变化" class="headerlink" title="五、torchvision的一些变化"></a>五、torchvision的一些变化</h3><p>1.torchvision.transform中函数<code>torchvision.transforms.`</code>Scale<code>(*args, **kwargs)即将被函数</code>torchvision.transforms.<code></code>Resize`(size, interpolation=2)代替。（参考官方文档：<a href="http://pytorch.org/docs/stable/torchvision/transforms.html#torchvision.transforms.Resize" target="_blank" rel="noopener">点击打开链接</a>）</p><p>2.torchvision.transform中函数<code>torchvision.transforms.`</code>RandomSizedCrop<code>(*args, **kwargs)即将被函数</code>torchvision.transforms.<code></code>RandomResizedCrop`(size, scale=(0.08, 1.0), ratio=(0.75, 1.3333333333333333), interpolation=2)代替。（参考官方文档：<a href="http://pytorch.org/docs/stable/torchvision/transforms.html#torchvision.transforms.RandomResizedCrop" target="_blank" rel="noopener">点击打开链接</a>）</p><h3 id="六、安装方式——Windows安装"><a href="#六、安装方式——Windows安装" class="headerlink" title="六、安装方式——Windows安装"></a>六、安装方式——Windows安装</h3><p>【方法一】pip直接安装。官网（<a href="http://pytorch.org/" target="_blank" rel="noopener">点击打开链接</a>）给出的安装步骤如下图所示（根据CUDA版本以及Python版本选择）。</p><p><img src="http://img0.ph.126.net/CToULoCCx_lmxB2-e1IPCg==/5717505544412384805.png" alt=""></p><p>Run this command:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip3 install http://download.pytorch.org/whl/cu90/torch-0.4.0-cp36-cp36m-win_amd64.whl </span><br><span class="line">pip3 install torchvision</span><br></pre></td></tr></table></figure><p>这里我是下载好torch-0.4.0-cp36-cp36m-win_amd64.whl文件到本地之后才安装的。<br>进入Anaconda Prompt，然后进入文件所在目录：</p><p>1.打开cmd命令提示符，先利用anaconda创建一个虚拟环境，命名为pytorch4<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n pytorch4 python=3.6</span><br></pre></td></tr></table></figure></p><p>2.激活刚才创建好的虚拟环境<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">activate pytorch4</span><br></pre></td></tr></table></figure></p><p>3.安装pytorch0.4.0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch-0.4.0-cp35-cp35m-win_amd64.whl</span><br></pre></td></tr></table></figure><p>注：根据自己的配置选择whl下载来链接</p><p>4.安装torchvision<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torchvision</span><br></pre></td></tr></table></figure></p><p>简单测试安装是否成功<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">python</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">print(torch.__version__)</span><br></pre></td></tr></table></figure></p><p>如果输出0.4.0，那么恭喜Windows下的PyTorch0.4.0安装成功！</p>]]></content>
      
      <categories>
          
          <category> PyTorch </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
            <tag> 深度学习 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>整数拆分</title>
      <link href="/2018/06/20/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/"/>
      <url>/2018/06/20/%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/</url>
      <content type="html"><![CDATA[<h2 id="整数拆分"><a href="#整数拆分" class="headerlink" title="整数拆分"></a>整数拆分</h2><p>给定一个正整数 n，将其拆分为至少两个正整数的和，并使这些整数的乘积最大化。 返回你可以获得的最大乘积。<br>例如，给定 n = 2，返回1（2 = 1 + 1）；给定 n = 10，返回36（10 = 3 + 3 + 4）。<br>注意：你可以假设 n 不小于2且不大于58。</p><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>任意大于等于2的正整数n都可以拆分为两个正整数之和，可以用dp数组存放n拆分后的乘积最大值，10 = 3 + 3 + 4可以拆分为10 = 6 + 4, dp[10] = dp[6] + dp[4]，而dp[6]和dp[4]又可以继续划分为dp[3] <em> dp[3]和d[2] </em> dp[2]…满足最优子结构性质，状态转移方程如下：<br>$dp[n] = max\langle dp[1]\cdot dp[n-1], dp[2]\cdot dp[n-2]\cdots dp[i]\cdot dp[n-i]\rangle$</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span> [n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">3</span>) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i/<span class="number">2</span>; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] * dp[i-j] &gt;= dp[i])&#123;</span><br><span class="line">                    dp[i] = Math.max(dp[j] * dp[i-j], i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>买卖股票的最佳时机</title>
      <link href="/2018/06/20/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/"/>
      <url>/2018/06/20/%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA/</url>
      <content type="html"><![CDATA[<h2 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h2><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。<br>设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。<br>注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p>示例 1:<br>输入: [7,1,5,3,6,4]<br>输出: 7<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。<br><a id="more"></a></p><p>示例 2:<br>输入: [1,2,3,4,5]<br>输出: 4<br>解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</p><p>示例 3:<br>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p><h4 id="普通解法"><a href="#普通解法" class="headerlink" title="普通解法"></a>普通解法</h4><p><strong>思路：由于买卖次数无限，所以只要能获利就进行买卖，这样能保证所有利润都吃到自然利润最大。</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length-<span class="number">1</span>; i++)&#123;</span><br><span class="line">            profit = prices[i+<span class="number">1</span>] - prices[i];</span><br><span class="line">            <span class="keyword">if</span>(profit &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sum += profit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p><strong>思路：用两个数组分别存放当前股票下两种状态——买和卖的最大值，最后卖出的即为最大利润</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] buy = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> [] sell = <span class="keyword">new</span> <span class="keyword">int</span>[len+<span class="number">1</span>];</span><br><span class="line">        buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            buy[i+<span class="number">1</span>] = Math.max(buy[i], sell[i]-prices[i]);</span><br><span class="line">            sell[i+<span class="number">1</span>] = Math.max(sell[i], buy[i]+prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最佳买卖股票时机含冷冻期"><a href="#最佳买卖股票时机含冷冻期" class="headerlink" title="最佳买卖股票时机含冷冻期"></a>最佳买卖股票时机含冷冻期</h2><h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>给定一个整数数组，其中第 i 个元素代表了第 i 天的股票价格 。​<br>设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</p><ul><li>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</li><li>卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。</li></ul><p>示例:<br>输入: [1,2,3,0,2]<br>输出: 3<br>解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>与上一题不同之处在于加入了一个冷冻期Cooldown，每支股票对应三种状态， 因此需要维护三个一维数组buy, sell，和rest。其中：<br>buy[i]表示在第i天之前最后一个操作是买，此时的最大收益。<br>sell[i]表示在第i天之前最后一个操作是卖，此时的最大收益。<br>rest[i]表示在第i天之前最后一个操作是冷冻期，此时的最大收益。</p><p>写出递推式为：</p><pre><code>buy[i]  = max(rest[i-1] - price, buy[i-1]) sell[i] = max(buy[i-1] + price, sell[i-1])rest[i] = max(sell[i-1], buy[i-1], rest[i-1])</code></pre><p>另外，由于冷冻期的存在，我们可以得出rest[i] = sell[i-1]，这样，我们可以将上面三个递推式精简到两个：</p><pre><code>buy[i]  = max(sell[i-2] - price, buy[i-1])sell[i] = max(buy[i-1] + price, sell[i-1])</code></pre><h4 id="动态规划-1"><a href="#动态规划-1" class="headerlink" title="动态规划"></a>动态规划</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 三个状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] buy = <span class="keyword">new</span> <span class="keyword">int</span> [len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> [] sell = <span class="keyword">new</span> <span class="keyword">int</span> [len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> [] rest = <span class="keyword">new</span> <span class="keyword">int</span> [len+<span class="number">1</span>];</span><br><span class="line">        buy[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            buy[i+<span class="number">1</span>] = Math.max(rest[i]-prices[i], buy[i]);</span><br><span class="line">            sell[i+<span class="number">1</span>] = Math.max(buy[i]+prices[i], sell[i]);</span><br><span class="line">            rest[i+<span class="number">1</span>] = Math.max(Math.max(sell[i], buy[i]), rest[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由rest[i] = sell[i-1]精简为两个状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = prices.length;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] buy = <span class="keyword">new</span> <span class="keyword">int</span> [len+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> [] sell = <span class="keyword">new</span> <span class="keyword">int</span> [len+<span class="number">1</span>];</span><br><span class="line">        buy[<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            buy[i+<span class="number">1</span>] = Math.max(sell[i-<span class="number">1</span>]-prices[i], buy[i]);</span><br><span class="line">            sell[i+<span class="number">1</span>] = Math.max(buy[i]+prices[i], sell[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>苏州项目USB通信协议</title>
      <link href="/2018/06/12/%E8%8B%8F%E5%B7%9E%E9%A1%B9%E7%9B%AE%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"/>
      <url>/2018/06/12/%E8%8B%8F%E5%B7%9E%E9%A1%B9%E7%9B%AE%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/</url>
      <content type="html"><![CDATA[<p>版本号：0.01<br>发行日期：2018-JUN-12</p><p>HID设备符<br>兼容：<br>    微软Windows 98、Windows2000、NT、XP、VISTA、WIN7、WIN8、WIN10，免驱动安装；<br>    Linux操作系统，免驱动安装。<br>    苹果Mac操作系统，免驱动安装</p><p>VID: 未定<br>PID: 未定</p><h3 id="液晶屏信息"><a href="#液晶屏信息" class="headerlink" title="液晶屏信息"></a>液晶屏信息</h3><p><img src="https://upload-images.jianshu.io/upload_images/12653638-dab5b47a41926eff.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>写入参数与命令均为16进制值。</strong><br><a id="more"></a></p><h3 id="系统信息命令：01"><a href="#系统信息命令：01" class="headerlink" title="系统信息命令：01"></a>系统信息命令：01</h3><pre><code>写入：01返回：ID:178636793830;sRev:1.00;hRev:1.00;Cmp:2018-06-08.说明：    ID：唯一序列号    sRev：软件版本号    hRev：硬件版本号    Cmp：发行日期</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12653638-7b929f670a0f3d15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="日期时间命令：02"><a href="#日期时间命令：02" class="headerlink" title="日期时间命令：02"></a>日期时间命令：02</h3><pre><code>写入：02返回：DtTm:18-06-12 13:43:33;CardCap:501219328 bytes.说明：    DtTm：日期与时间    CardCap：卡容量</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12653638-718bee2a1a5398a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="日期时间校正命令：03"><a href="#日期时间校正命令：03" class="headerlink" title="日期时间校正命令：03"></a>日期时间校正命令：03</h3><pre><code>写入：03 18 06 12 13 45 12返回：DtTm:18-06-12 13:45:12;说明：    DtTm：日期与时间</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12653638-3cf589a2944ec2be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="用户名与密码主命令：04"><a href="#用户名与密码主命令：04" class="headerlink" title="用户名与密码主命令：04"></a>用户名与密码主命令：04</h3><p><strong>检查用户名与密码子命令：04 00</strong></p><pre><code>写入：DtTm:18-06-12 13:45:12;返回：Rslt:0结果为0表示已设置，不为0则未设置。</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12653638-edbf31013c5d3323.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>设置用户名与密码子命令：04 01</strong></p><pre><code>写入：04 01 0C 54 65 73 74 55 73 65 72 4E 61 6D 31 0F 54 65 73 74 50 61 73 73 77 6F 72 64 31 32 33 返回：Name:TestUserNam1;Pasd:TestPassword123;Rslt:0.说明：    帧结构：    04 01 + 用户名称长度 + 用户名 +密码长度 + 密码    上例中：    04 01 =&gt; 主命令 + 子命令    0C =&gt; 用户名长度    54 65 73 74 55 73 65 72 4E 61 6D 31 =&gt; 用户名    0F =&gt; 密码长度    54 65 73 74 50 61 73 73 77 6F 72 64 31 32 33 =&gt; 密码    Name：用户名 =&gt; 取值范围：限十进制33至十进制122之间的可打印字符，共90个字符。            取值长度：最大16个字符长度。    Pasd：用户密码 =&gt; 取值范围：限十进制33至十进制122之间的可打印字符，共90个字符。             取值长度：最大16个字符长度。    Rslt：执行结果        结果 =0：表示已执行成功            =1：执行失败            =2：执行失败，名称非法的字符值,不是可打印字符            =3：执行失败，密码非法的字符值,不是可打印字符        </code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12653638-d211f457ebc65d6a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>登录系统子命令：04 02</strong></p><pre><code>写入：04 02 0C 54 65 73 74 55 73 65 72 4E 61 6D 31 0F 54 65 73 74 50 61 73 73 77 6F 72 64 31 32 33 返回：Rslt:0结果为0表示已登录系统，不为0则为登录失败。帧结构与“设置用户名与密码子命令”相同。</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12653638-bc9ff2f587c89430.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><strong>读出用户名与密码子命令：04 03</strong></p><pre><code>写入：04 03返回：Name:TestUserNam1;Pasd:TestPassword123.说明：Name：用户名 =&gt; TestUserNam1Pasd：用户密码 =&gt; TestPassword123</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12653638-8044fab0a0d51711.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="读取模具检修次数命令：05"><a href="#读取模具检修次数命令：05" class="headerlink" title="读取模具检修次数命令：05"></a>读取模具检修次数命令：05</h3><pre><code>写入：05返回：ModiTms:00000.说明：模具检修次数&quot;ModiTms&quot;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12653638-69d9d465958b1570.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="设定服务器IP地址和端口命令：06"><a href="#设定服务器IP地址和端口命令：06" class="headerlink" title="设定服务器IP地址和端口命令：06"></a>设定服务器IP地址和端口命令：06</h3><pre><code>写入：06 11 77 77 77 2E 73 6D 61 72 74 77 61 6C 65 2E 63 6F 6D 00 28返回：IP:www.smartwale.com;Port:10240.Rslt：执行结果      结果 =0：表示已执行成功           =4：域名或IP地址长度超过32个字符           =5：端口号过大或过小           =6：域名中包含非法字符,取值范围：限十进制33至十进制122之间的可打印字符，共90个字符。说明：帧结构：06 + 域名[或IP地址]长度 + 域名[或IP地址] + 2字节端口号上例中：  命令：            06  IP地址长度：      11  域名[或IP地址]：  77 77 77 2E 73 6D 61 72 74 77 61 6C 65 2E 63 6F 6D ==&gt; www.smartwale.com  端口号：          00 28 ==&gt; 10240; 注意：  端口号取值范围：1024 ≤ 取值范围 ≤ 60000</code></pre><h3 id="读取服务器IP地址和端口命令：07"><a href="#读取服务器IP地址和端口命令：07" class="headerlink" title="读取服务器IP地址和端口命令：07"></a>读取服务器IP地址和端口命令：07</h3><pre><code>写入：07返回：IP:www.smartwale.com;Port:10240.</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12653638-307084c2d6add446.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="读取所有WIFI-AP名称命令：08"><a href="#读取所有WIFI-AP名称命令：08" class="headerlink" title="读取所有WIFI-AP名称命令：08"></a>读取所有WIFI-AP名称命令：08</h3><p><strong>读取WIFI-AP数量：08 00</strong></p><pre><code>写入：08 00返回：QtyAP:06.      未就绪时返回：Rslt:6说明：    * 就绪时返回已找到的WIFI-AP数量;    * 未就绪返回错误代码&quot;Rslt:6&quot;;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12653638-1e193e0ce557d019.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><strong>读取指定的第n个WIFI-AP的名称、端口等参数：08 01</strong></p><pre><code>写入：08 01 01返回：Numbxx:&lt;加密方式&gt;,&lt;名称&gt;,&lt;信号强度&gt;,&lt;MAC地址&gt;,&lt;信道号&gt;例：    Numb01:4,&quot;ABC&quot;,-87,&quot;0c:82:68:bf:01:16&quot;,1说明：      写入格式：08 01 + 第n个WIFI-AP      加密方式：        =0：开放        =1：WEP        =2：WPA_PSK        =3：WPA_2PSK        =4：WPA_WPA2_PSK</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12653638-2eebf23ea9aa8ad0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="设置需要连接的WIFI-AP、密码命令：09"><a href="#设置需要连接的WIFI-AP、密码命令：09" class="headerlink" title="设置需要连接的WIFI-AP、密码命令：09"></a>设置需要连接的WIFI-AP、密码命令：09</h3><pre><code>写入：09 03 00 41 42 43 返回：NamAP:ABC;Password:Null.说明：  写入格式：09 + AP名称长度 + 密码长度 + AP名称 + 密码  返回格式：      AP名称：NamAP:ABC; ==&gt; 长度限制16个字符，限可打印字符;      访问密码：Password:Null. ==&gt; 长度限制16个字符，限可打印字符;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/12653638-cc28dcdc5d048d6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="读取已设定的AP名称与密码：0A"><a href="#读取已设定的AP名称与密码：0A" class="headerlink" title="读取已设定的AP名称与密码：0A"></a>读取已设定的AP名称与密码：0A</h3><pre><code>写入：0A返回：NamAP:ABC;Password:Null.说明：  返回格式：      NamAP:ABC;Password:Null.</code></pre><h3 id="更新AP名称列表：0B"><a href="#更新AP名称列表：0B" class="headerlink" title="更新AP名称列表：0B"></a>更新AP名称列表：0B</h3><pre><code>写入：0B返回：Rslt:0  </code></pre>]]></content>
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 杂项 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python爬虫</title>
      <link href="/2018/06/09/Python%E7%88%AC%E8%99%AB/"/>
      <url>/2018/06/09/Python%E7%88%AC%E8%99%AB/</url>
      <content type="html"><![CDATA[<h2 id="文本爬取"><a href="#文本爬取" class="headerlink" title="文本爬取"></a>文本爬取</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> requests,urllib3.request,time,os</span><br><span class="line"><span class="keyword">import</span> random,csv,socket,http.client</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_contend</span><span class="params">(url, data = None)</span>:</span>  <span class="comment">#获取网页中html代码</span></span><br><span class="line">    header=&#123;<span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">        <span class="string">'Accept-Encoding'</span>: <span class="string">'zh-CN,zh;q=0.9'</span>,</span><br><span class="line">        <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.8'</span>,</span><br><span class="line">        <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">        <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'</span></span><br><span class="line">        &#125;</span><br><span class="line">    timeout = random.choice(range(<span class="number">80</span>,<span class="number">180</span>))</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            rep = requests.get(url,headers = header,timeout=timeout)</span><br><span class="line">            rep.encoding = <span class="string">'utf-8'</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">except</span> socket.timeout <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'3'</span>,e)</span><br><span class="line">            time.sleep(random.choice.range(<span class="number">8</span>,<span class="number">15</span>))</span><br><span class="line">        <span class="keyword">except</span> socket.error <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'4'</span>,e)</span><br><span class="line">            time.sleep(random.choice.range(<span class="number">20</span>,<span class="number">60</span>))</span><br><span class="line">        <span class="keyword">except</span> http.client.BadStatusLine <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'5'</span>,e)</span><br><span class="line">            time.sleep(random.choice.range(<span class="number">30</span>,<span class="number">80</span>))</span><br><span class="line">        <span class="keyword">except</span> http.client.IncompleteRead <span class="keyword">as</span> e:</span><br><span class="line">            <span class="keyword">print</span> (<span class="string">'6'</span>,e)</span><br><span class="line">            time.sleep(random.choice.range(<span class="number">5</span>,<span class="number">15</span>))</span><br><span class="line">    <span class="keyword">return</span> rep.text</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_data</span><span class="params">(html_text)</span>:</span></span><br><span class="line">    final = []</span><br><span class="line">    bs = BeautifulSoup(html_text,<span class="string">'html.parser'</span>) <span class="comment">#创建BeautifulSoup对象</span></span><br><span class="line">    body = bs.body  <span class="comment">#获取body部分</span></span><br><span class="line">    data = body.find(<span class="string">'div'</span>,&#123;<span class="string">'id'</span>:<span class="string">'7d'</span>&#125;) <span class="comment">#找到需要爬取部分的div</span></span><br><span class="line">    ul = data.find(<span class="string">'ul'</span>)   <span class="comment">#获取ul部分</span></span><br><span class="line">    li = ul.find_all(<span class="string">'li'</span>)  <span class="comment">#获取所有的li</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> day <span class="keyword">in</span> li:  <span class="comment">#对li标签中内容进行遍历</span></span><br><span class="line">        temp = []</span><br><span class="line">        date =day.find(<span class="string">'h1'</span>).string <span class="comment">#找到日期</span></span><br><span class="line">        temp.append(date)   <span class="comment">#将日期添加到temp中</span></span><br><span class="line">        p = day.find_all(<span class="string">'p'</span>)   <span class="comment">#找到每个li中的所有p标签</span></span><br><span class="line">        temp.append(p[<span class="number">0</span>].string,)    <span class="comment">#第一个p标签中的天气状况添加到temp</span></span><br><span class="line">        <span class="keyword">if</span> p[<span class="number">1</span>].find(<span class="string">'span'</span>) == <span class="keyword">None</span>:</span><br><span class="line">            t_highest = <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            t_highest = p[<span class="number">1</span>].find(<span class="string">'span'</span>).string    <span class="comment">#找到最高温</span></span><br><span class="line">            t_highest = t_highest.replace(<span class="string">'C'</span>,<span class="string">''</span>)</span><br><span class="line">        t_lowest = p[<span class="number">1</span>].find(<span class="string">'i'</span>).string  <span class="comment"># 找到最低温</span></span><br><span class="line">        t_lowest = t_lowest.replace(<span class="string">'C'</span>,<span class="string">''</span>)</span><br><span class="line">        temp.append(t_highest)</span><br><span class="line">        temp.append(t_lowest)</span><br><span class="line">        final.append(temp)</span><br><span class="line">    <span class="keyword">return</span> final</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write_data</span><span class="params">(data,name)</span>:</span>  <span class="comment">#将数据写入文件</span></span><br><span class="line">    file_name = name</span><br><span class="line">    <span class="keyword">with</span> open(file_name, <span class="string">'a'</span>, errors=<span class="string">'ignore'</span>, newline=<span class="string">''</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f_csv = csv.writer(f)</span><br><span class="line">        f_csv.writerows(data)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    url = <span class="string">'http://www.weather.com.cn/weather/101190401.shtml'</span></span><br><span class="line">    html = get_contend(url)</span><br><span class="line">    result = get_data(html)</span><br><span class="line">    print(result)</span><br><span class="line">    write_data(result,<span class="string">'weather.csv'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="图虫图片爬取"><a href="#图虫图片爬取" class="headerlink" title="图虫图片爬取"></a>图虫图片爬取</h2><h3 id="按标签爬取"><a href="#按标签爬取" class="headerlink" title="按标签爬取"></a>按标签爬取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">__author__ = <span class="string">'Result_Lv'</span></span><br><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_json</span><span class="params">(url)</span>:</span></span><br><span class="line">    header = &#123;<span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">              <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">              <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.9'</span>,</span><br><span class="line">              <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">              <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'</span></span><br><span class="line">              &#125;</span><br><span class="line">    rep = requests.get(url, headers = header)   <span class="comment">#请求json地址</span></span><br><span class="line">    json_dict = json.loads(rep.text)            <span class="comment">#解析json</span></span><br><span class="line">    <span class="keyword">return</span> json_dict                            <span class="comment">#返回json字典</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_album_name</span><span class="params">(json_dict)</span>:</span></span><br><span class="line">    album_name = []</span><br><span class="line">    postlist = json_dict[<span class="string">'postList'</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(postlist)):</span><br><span class="line">        <span class="keyword">if</span> postlist[i][<span class="string">'title'</span>] == <span class="string">''</span>:                  <span class="comment">#图集标题为空时，命名为默认</span></span><br><span class="line">            album_name.append(<span class="string">'Default'</span> + str(i))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            album_name.append(postlist[i][<span class="string">'title'</span>])</span><br><span class="line">    <span class="keyword">return</span> album_name</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_photo_id</span><span class="params">(json_dict)</span>:</span>   <span class="comment">#获得所有照片的ID</span></span><br><span class="line">    author_id = []</span><br><span class="line">    album_id = []</span><br><span class="line">    post_list = json_dict[<span class="string">'postList'</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(post_list)):                                     <span class="comment">#获取每个图集的照片ID</span></span><br><span class="line">        photo_id = []</span><br><span class="line">        author_id.append(post_list[i][<span class="string">'author_id'</span>])                     <span class="comment"># 获取每个图集作者ID</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(post_list[i][<span class="string">'images'</span>])):</span><br><span class="line">            photo_id.append(post_list[i][<span class="string">'images'</span>][j][<span class="string">'img_id'</span>])        <span class="comment">#将所有每个图集里的照片全部添加到list</span></span><br><span class="line">        album_id.append(photo_id)</span><br><span class="line">    <span class="keyword">return</span> author_id,album_id</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_album</span><span class="params">(path,album_name,author_id,album_id)</span>:</span>     <span class="comment">#下载图集</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(album_id)):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path + album_name[i]):        <span class="comment">#若不存在对应图集的文件夹</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                os.makedirs(path + album_name[i])           <span class="comment">#以图集名创建文件夹</span></span><br><span class="line">            <span class="keyword">except</span> OSError <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">        print(<span class="string">'正在下载第'</span> + str(i + <span class="number">1</span>) + <span class="string">'个图册:'</span> + album_name[i])</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(album_id[i])):</span><br><span class="line">            fileurl = <span class="string">'https://photo.tuchong.com/'</span> + str(author_id[i]) +<span class="string">'/f/'</span> + str(album_id[i][j]) + <span class="string">'.jpg'</span>    <span class="comment">#生成每张照片Url</span></span><br><span class="line">            filename = path + album_name[i] + <span class="string">'/'</span> + str(j+<span class="number">1</span>) + <span class="string">'.jpg'</span>                                           <span class="comment">#命名照片</span></span><br><span class="line">            print(<span class="string">'    正在下载第'</span> + str(j+<span class="number">1</span>) + <span class="string">'张照片:'</span> + fileurl)</span><br><span class="line">            <span class="keyword">with</span> open(filename,<span class="string">'w'</span>):</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    request.urlretrieve(fileurl,filename)   <span class="comment">#下载照片</span></span><br><span class="line">                    time.sleep(np.random.rand())            <span class="comment">#下载间隔</span></span><br><span class="line">                <span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">                    print(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    page = <span class="number">3</span>              <span class="comment">#爬取页数</span></span><br><span class="line">    path = <span class="string">'F:/少女/'</span>     <span class="comment">#存放路径</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(page):</span><br><span class="line">        url = <span class="string">'https://tuchong.com/rest/tags/少女/posts?page='</span> + str(i+<span class="number">1</span>) + <span class="string">'&amp;count=20&amp;order=weekly'</span>  <span class="comment">#tag的json地址</span></span><br><span class="line">        json_dict = get_json(url)</span><br><span class="line">        album_name = get_album_name(json_dict)</span><br><span class="line">        para = get_photo_id(json_dict)</span><br><span class="line">        author_id = para[<span class="number">0</span>]</span><br><span class="line">        album_id = para[<span class="number">1</span>]</span><br><span class="line">        download_album(path,album_name,author_id,album_id)</span><br></pre></td></tr></table></figure><h3 id="按作者爬取"><a href="#按作者爬取" class="headerlink" title="按作者爬取"></a>按作者爬取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,error</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_json</span><span class="params">(url)</span>:</span>  <span class="comment">#解析json</span></span><br><span class="line">    header = &#123;<span class="string">'Accept'</span>: <span class="string">'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8'</span>,</span><br><span class="line">              <span class="string">'Accept-Encoding'</span>: <span class="string">'gzip, deflate, br'</span>,</span><br><span class="line">              <span class="string">'Accept-Language'</span>: <span class="string">'zh-CN,zh;q=0.9'</span>,</span><br><span class="line">              <span class="string">'Connection'</span>: <span class="string">'keep-alive'</span>,</span><br><span class="line">              <span class="string">'User-Agent'</span>: <span class="string">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/62.0.3202.94 Safari/537.36'</span></span><br><span class="line">              &#125;</span><br><span class="line">    rep = requests.get(url, headers = header)   <span class="comment">#请求json地址</span></span><br><span class="line">    json_dict = json.loads(rep.text)            <span class="comment">#解析json</span></span><br><span class="line">    <span class="keyword">return</span> json_dict                            <span class="comment">#返回json字典</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_all_photo_id</span><span class="params">(json_dict)</span>:</span>   <span class="comment">#获得所有照片的ID</span></span><br><span class="line">    <span class="comment">#post_id = []</span></span><br><span class="line">    photo_id = []</span><br><span class="line">    post_list = json_dict[<span class="string">'post_list'</span>]</span><br><span class="line">    author_id = post_list[<span class="number">0</span>][<span class="string">'author_id'</span>]                               <span class="comment">#获取作者ID</span></span><br><span class="line">    author_name = post_list[<span class="number">0</span>][<span class="string">'site'</span>][<span class="string">'name'</span>]                          <span class="comment">#获取作者姓名</span></span><br><span class="line">    <span class="comment"># for i in range(len(post_list)):                                   #获取所有图集ID</span></span><br><span class="line">    <span class="comment">#     post_id.append(post_list[i]['post_id'])</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(post_list)):                                     <span class="comment">#获取每个图集的照片ID</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(len(post_list[i][<span class="string">'images'</span>])):</span><br><span class="line">            photo_id.append(post_list[i][<span class="string">'images'</span>][j][<span class="string">'img_id'</span>])        <span class="comment">#将所有每个图集里的照片全部添加到list</span></span><br><span class="line">    <span class="keyword">return</span> author_name,author_id,photo_id</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_photo</span><span class="params">(path,author_id,photo_id)</span>:</span>    <span class="comment">#下载全部照片</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(path):</span><br><span class="line">        os.makedirs(path)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(photo_id)):</span><br><span class="line">        filename = path + <span class="string">'/'</span> + str(i+<span class="number">1</span>) + <span class="string">'.jpg'</span></span><br><span class="line">        fileurl = <span class="string">'https://photo.tuchong.com/'</span> + str(author_id) + <span class="string">'/f/'</span> + str(photo_id[i]) + <span class="string">'.jpg'</span></span><br><span class="line">        print(<span class="string">'    第'</span> + str(i + <span class="number">1</span>) + <span class="string">'张图片:'</span> + fileurl)</span><br><span class="line">        <span class="keyword">with</span> open(filename,<span class="string">'w'</span>):</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                request.urlretrieve(fileurl,filename)   <span class="comment">#下载照片</span></span><br><span class="line">                time.sleep(np.random.rand())            <span class="comment">#下载间隔</span></span><br><span class="line">            <span class="keyword">except</span> error.HTTPError <span class="keyword">as</span> e:</span><br><span class="line">                print(e)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    page = <span class="number">3</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(page):</span><br><span class="line">        url = <span class="string">'https://thomaskksj.tuchong.com/rest/2/sites/395013/posts?count=20&amp;page='</span> + str(i + <span class="number">1</span>)  <span class="comment">#作者主页的json地址</span></span><br><span class="line">        print(<span class="string">'正在下载第'</span> + str(i+<span class="number">1</span>) + <span class="string">'页:'</span> + url)</span><br><span class="line">        json_dict = get_json(url)</span><br><span class="line">        para = get_all_photo_id(json_dict)</span><br><span class="line">        author_name = para[<span class="number">0</span>]</span><br><span class="line">        author_id = para[<span class="number">1</span>]</span><br><span class="line">        photo_id = para[<span class="number">2</span>]</span><br><span class="line">        path = <span class="string">'F:/'</span> + author_name + <span class="string">'/page'</span> + str(i + <span class="number">1</span>)</span><br><span class="line">        download_photo(path,author_id,photo_id)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 爬虫 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>机器学习相关</title>
      <link href="/2018/06/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/"/>
      <url>/2018/06/09/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/</url>
      <content type="html"><![CDATA[<h2 id="集成学习"><a href="#集成学习" class="headerlink" title="集成学习"></a>集成学习</h2><p>集成学习（Ensemble learning）通过组合几种模型来提高机器学习的效果。与单一模型相比，该方法可以提供更好的预测结果。集成方法是将几种机器学习技术组合成一个预测模型的元算法，以达到减小方差（bagging）、偏差（boosting）或改进预测（stacking）的效果</p><h3 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h3><p>Bagging 是 bootstrap aggregation 的缩写。通过对训练样本重新采样的方法得到不同的训练样本集，在这些新的训练样本集上分别训练学习器，最终合并每一个学习器的结果，作为最终的学习结果，Bagging方法的具体过程如下图所示：<br><img src="http://img1.ph.126.net/2SQWgzFB-8DEOeD4mIvoLw==/1913466891779385955.png" alt=""><br>在Bagging方法中，最重要的算法为随机森林Random Forest算法。<br>在随机森林中，集成中的每棵树都是由从训练集中抽取的样本（即 bootstrap 样本）构建的。另外，与使用所有特征不同，这里随机选择特征子集，从而进一步达到对树的随机化目的。而最终结果采用Bagging的策略来获得，即多数投票机制<br>因此，随机森林产生的偏差略有增加，但是由于对相关性较小的树计算平均值，估计方差减小了，导致模型的整体效果更好</p><a id="more"></a><h3 id="Boosting"><a href="#Boosting" class="headerlink" title="Boosting"></a>Boosting</h3><p>Boosting算法中，学习器之间是存在先后顺序的，同时，每一个样本是有权重的，初始时，每一个样本的权重是相等的。首先，第1个学习器对训练样本进行学习，当学习完成后，增大错误样本的权重，同时减小正确样本的权重，再利用第2个学习器对其进行学习，依次进行下去，最终得到b个学习器，最终，合并这b个学习器的结果，同时，与Bagging中不同的是，每一个学习器的权重也是不一样的。Boosting方法的具体过程如下图所示：<br><img src="http://img0.ph.126.net/i3rJZkYoe25OB8y4qz7P1Q==/1286903593541391594.png" alt=""><br>然后通过结合加权多数投票（分类）或加权求和（回归）以产生最终预测。Boosting 与 bagging 等方法的主要区别是基础学习器通过加权的数据进行顺序训练。<br>在Boosting方法中，最重要的方法包括：AdaBoost和GBDT</p><h4 id="GBDT-梯度提升决策树"><a href="#GBDT-梯度提升决策树" class="headerlink" title="GBDT-梯度提升决策树"></a>GBDT-梯度提升决策树</h4><p>梯度提升决策树Gradient Boosting Decision Tree是Gradient Boost框架下使用较多的一种模型，在梯度提升决策树中，其基学习器是分类回归树CART，使用的是CART树中的回归树。<br><strong>DT（Decision Tree）决策树。</strong>T自不必多说，作为一种常见的数据结构出现在各种算法当中。DT决策树，有分类树与回归树两种，之前文章中讲到了分类树，可参见 与 。回归树原理机制与分类树相似，区别在于分类树只有在叶子结点返回唯一分类，而回归树的每个节点都能返回预测值，通常为当前节点下所有样本的均值。<br><strong>B（Boosting）提升。</strong>即在原来模型的基础之上做进一步提升，提升决策树BDT的基本思想是采用多棵决策树串行建模。具体过程为，对于第一棵树之后的每一棵决策树，都基于前一棵决策树的输出进行二次建模，整个串行建模过程相当于对预测结果朝目标值进行修正。<br><strong>G（Gradient）梯度。</strong>梯度的大小反映了当前预测值与目标值之间的距离。因此，上面B所述的串行决策树模型，除开第一棵决策树使用原始预测指标建树，之后的每一棵决策树都用前一棵决策树的预测值与目标值计算出来的负梯度（可以理解为残差或者增量）来建树。这相当于给分错的样本加权多次分类，使样本最终的残差趋近于0。除开第一棵树的其他树，由于都是对目标的残差或增量进行建模预测，因此GBDT模型只需把过程中每一棵决策树的输出结果累加，便可得到最终的预测输出。</p><h3 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h3><p>Stacking 是一种集成学习技术，通过元分类器或元回归聚合多个分类或回归模型。基础层次模型（level model）基于完整的训练集进行训练，然后元模型基于基础层次模型的输出进行训练。<br>基础层次通常由不同的学习算法组成，因此 stacking 集成通常是异构的</p><h2 id="正则化-防止过拟合，提高泛化能力"><a href="#正则化-防止过拟合，提高泛化能力" class="headerlink" title="正则化-防止过拟合，提高泛化能力"></a><a href="https://blog.csdn.net/u012162613/article/details/44261657" target="_blank" rel="noopener">正则化-防止过拟合，提高泛化能力</a></h2><p>在训练数据不够多时，或者overtraining时，常常会导致overfitting（过拟合），避免过拟合的方法有很多：early stopping、数据集扩增（Data augmentation）、正则化（Regularization）包括L1、L2（L2 regularization也叫weight decay），dropout等。<br>采用正则化方法会自动削弱不重要的特征变量，自动从许多的特征变量中”提取“重要的特征变量，减小特征变量的数量级。</p><h3 id="L1和L2正则为何可以减弱over-fitting，L1和L2正则有什么区别"><a href="#L1和L2正则为何可以减弱over-fitting，L1和L2正则有什么区别" class="headerlink" title="L1和L2正则为何可以减弱over-fitting，L1和L2正则有什么区别"></a>L1和L2正则为何可以减弱over-fitting，L1和L2正则有什么区别</h3><p>正则化通过降低模型的复杂性， 达到避免过拟合的问题。</p><h4 id="L2正则化："><a href="#L2正则化：" class="headerlink" title="L2正则化："></a>L2正则化：</h4><p><img src="http://img2.ph.126.net/pFRlEIZ8WYWfoYxS0-1HOw==/6597612925402944542.png" alt=""><br>在不使用L2正则化时。求导结果中w前系数为1，如今w前面系数为 1−ηλ/n ，由于η、λ、n都是正的。所以 1−ηλ/n小于1，它的效果是减小w。这也就是权重衰减（weight decay）的由来。更小的权值w，从某种意义上说，表示网络的复杂度更低，对数据的拟合刚刚好。</p><h4 id="L1正则化"><a href="#L1正则化" class="headerlink" title="L1正则化"></a>L1正则化</h4><p><img src="http://img1.ph.126.net/3Hb3s0EZYUe3kSa3pOVJzQ==/6597960371077331326.png" alt=""><br>当w为正时，更新后的w变小。<br>当w为负时。更新后的w变大——因此它的效果就是让w往0靠。使网络中的权重尽可能为0，也就相当于减小了网络复杂度，防止过拟合</p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>L1范数是指向量中各个元素绝对值之和，用于特征选择;<br>L2范数 是指向量各元素的平方和然后求平方根，用于 防止过拟合，提升模型的泛化能力<br>L1与L2区别：使用L1可以得到稀疏的权值；用L2可以得到平滑的权值</p><h3 id="L1和L2正则化直观理解"><a href="#L1和L2正则化直观理解" class="headerlink" title="L1和L2正则化直观理解"></a>L1和L2正则化直观理解</h3><p><img src="http://img0.ph.126.net/2V0udHo4Azq_EBTafvELxw==/2968716579467654289.png" alt=""></p>]]></content>
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>mnist识别</title>
      <link href="/2018/06/09/mnist%E8%AF%86%E5%88%AB/"/>
      <url>/2018/06/09/mnist%E8%AF%86%E5%88%AB/</url>
      <content type="html"><![CDATA[<h3 id="minist-mpl-py"><a href="#minist-mpl-py" class="headerlink" title="minist_mpl.py"></a>minist_mpl.py</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense,Activation,Dropout</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD,Adadelta</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> save_model</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">(x_train,y_train),(x_test,y_test) = mnist.load_data()</span><br><span class="line">x_train = x_train.reshape(<span class="number">60000</span>,<span class="number">28</span>*<span class="number">28</span>).astype(<span class="string">'float32'</span>)  <span class="comment">#转换数据格式</span></span><br><span class="line">x_test = x_test.reshape(<span class="number">10000</span>,<span class="number">28</span>*<span class="number">28</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line"></span><br><span class="line">x_train /= <span class="number">255</span>   <span class="comment">#训练数据归一化</span></span><br><span class="line">x_test /= <span class="number">255</span></span><br><span class="line"></span><br><span class="line">y_train = keras.utils.to_categorical(y_train,<span class="number">10</span>)    <span class="comment">#one-hot编码</span></span><br><span class="line">y_test = keras.utils.to_categorical(y_test,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">print(x_train.shape,y_train.shape,x_test.shape,y_test.shape)</span><br><span class="line">modle = Sequential()</span><br><span class="line"><span class="comment">#第一层隐层，64个神经元</span></span><br><span class="line">modle.add(Dense(<span class="number">256</span>,activation=<span class="string">'relu'</span>,input_dim=<span class="number">28</span>*<span class="number">28</span>))</span><br><span class="line"><span class="comment">#第二层隐层，64个神经元</span></span><br><span class="line">modle.add(Dense(<span class="number">256</span>,activation=<span class="string">'relu'</span>))</span><br><span class="line">modle.add(Dropout(<span class="number">0.5</span>))</span><br><span class="line"><span class="comment">#输出层，10个神经元</span></span><br><span class="line">modle.add(Dense(<span class="number">10</span>,activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">sgd = SGD(lr=<span class="number">0.01</span>,decay=<span class="number">1e-6</span>,momentum=<span class="number">0.9</span>,nesterov=<span class="keyword">True</span>)</span><br><span class="line">modle.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=<span class="string">'adagrad'</span>,metrics=[<span class="string">'accuracy'</span>])</span><br><span class="line"></span><br><span class="line">modle.fit(x_train,y_train,epochs=<span class="number">10</span>,batch_size=<span class="number">128</span>)</span><br><span class="line">score = modle.evaluate(x_test,y_test,batch_size=<span class="number">128</span>)</span><br><span class="line">print(score)</span><br><span class="line">modle.save(<span class="string">'MLP_minist.h5'</span>)</span><br></pre></td></tr></table></figure><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#encoding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> keras</span><br><span class="line"><span class="keyword">from</span> keras.datasets <span class="keyword">import</span> mnist</span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential,save_model</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense,Dropout,Flatten,Conv2D,MaxPooling2D</span><br><span class="line"><span class="keyword">from</span> keras.optimizers <span class="keyword">import</span> SGD,Adadelta</span><br><span class="line"></span><br><span class="line">(x_train,y_train),(x_test,y_test) = mnist.load_data()   <span class="comment">#加载数据</span></span><br><span class="line">print(x_train.shape,x_test.shape)</span><br><span class="line">x_train = x_train.reshape(<span class="number">60000</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>).astype(<span class="string">'float32'</span>)  <span class="comment">#二维数据</span></span><br><span class="line">x_test = x_test.reshape(<span class="number">10000</span>,<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>).astype(<span class="string">'float32'</span>)</span><br><span class="line"></span><br><span class="line">x_train /= <span class="number">255</span>  <span class="comment">#训练数据归一化</span></span><br><span class="line">x_test /= <span class="number">255</span></span><br><span class="line"></span><br><span class="line">y_train = keras.utils.to_categorical(y_train)    <span class="comment">#one-hot编码</span></span><br><span class="line">y_test = keras.utils.to_categorical(y_test)</span><br><span class="line">num_classes = y_test.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">model = Sequential()    <span class="comment">#创建序列模型</span></span><br><span class="line">model.add(Conv2D(<span class="number">64</span>,(<span class="number">3</span>,<span class="number">3</span>),activation=<span class="string">'relu'</span>,input_shape=(<span class="number">28</span>,<span class="number">28</span>,<span class="number">1</span>)))  <span class="comment">#第一层卷积层</span></span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))    <span class="comment">#池化层</span></span><br><span class="line"></span><br><span class="line">model.add(Conv2D(<span class="number">64</span>,(<span class="number">3</span>,<span class="number">3</span>),activation=<span class="string">'relu'</span>))  <span class="comment">#第二层卷积层</span></span><br><span class="line">model.add(MaxPooling2D(pool_size=(<span class="number">2</span>,<span class="number">2</span>)))    <span class="comment">#池化层</span></span><br><span class="line"></span><br><span class="line">model.add(Flatten())    <span class="comment">#铺平当前节点</span></span><br><span class="line"></span><br><span class="line">model.add(Dense(<span class="number">128</span>,activation=<span class="string">'relu'</span>))     <span class="comment">#全连接层</span></span><br><span class="line">model.add(Dropout(<span class="number">0.5</span>)) <span class="comment">#随机失活</span></span><br><span class="line">model.add(Dense(num_classes,activation=<span class="string">'softmax'</span>))</span><br><span class="line"></span><br><span class="line">model.compile(loss=<span class="string">'categorical_crossentropy'</span>,optimizer=<span class="string">'adam'</span>,metrics=[<span class="string">'accuracy'</span>])   <span class="comment">#编译模型</span></span><br><span class="line">model.fit(x_train,y_train,batch_size=<span class="number">128</span>,epochs=<span class="number">10</span>)     <span class="comment">#训练模型</span></span><br><span class="line">score = model.evaluate(x_test,y_test,batch_size=<span class="number">128</span>)    <span class="comment">#评价模型</span></span><br><span class="line"></span><br><span class="line">print(score)    <span class="comment">#打印分类准确率</span></span><br><span class="line"></span><br><span class="line">model.save(<span class="string">'CNN_minist.h5'</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 深度学习 </tag>
            
            <tag> Keras </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>快排</title>
      <link href="/2018/06/09/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2018/06/09/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<h3 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = low;</span><br><span class="line"><span class="keyword">int</span> h = high;</span><br><span class="line"><span class="keyword">int</span> key = arr[low];</span><br><span class="line"><span class="keyword">if</span>(l &gt;= h) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 划分集合</span></span><br><span class="line"><span class="keyword">while</span>(l &lt; h) &#123;</span><br><span class="line"><span class="keyword">while</span>(arr[h] &gt;= key &amp;&amp; h &gt; l) &#123;</span><br><span class="line">h--;</span><br><span class="line">&#125;</span><br><span class="line">arr[l] = arr[h];</span><br><span class="line"><span class="keyword">while</span>(arr[l] &lt;= key &amp;&amp; l &lt; h) &#123;</span><br><span class="line">l++;</span><br><span class="line">&#125;</span><br><span class="line">arr[h] = arr[l];</span><br><span class="line">&#125;</span><br><span class="line">arr[l] = key;</span><br><span class="line"><span class="comment">// 递归调用</span></span><br><span class="line"><span class="keyword">if</span>(l &gt; low) &#123;</span><br><span class="line">quickSort(arr, low, l-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(h &lt; high) &#123;</span><br><span class="line">quickSort(arr, l+<span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>链表实现</title>
      <link href="/2018/06/09/%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/06/09/%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkList</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">private</span> Node next;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.data = data;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> Node head;<span class="comment">// 头指针</span></span><br><span class="line"><span class="keyword">private</span> Node tail = <span class="keyword">new</span> Node(); <span class="comment">// 尾指针</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">circulation</span><span class="params">()</span> </span>&#123; <span class="comment">// 连接为循环链表</span></span><br><span class="line">Node temp = head;</span><br><span class="line"><span class="keyword">while</span>(temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line">tail = temp;</span><br><span class="line">tail.next = head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;<span class="comment">// 添加结点</span></span><br><span class="line"><span class="keyword">if</span>(head == <span class="keyword">null</span>) &#123;<span class="comment">// 没有头结点则添加头结点</span></span><br><span class="line">head = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">size++;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node temp = head;</span><br><span class="line"><span class="keyword">while</span>(temp.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line">temp.next = <span class="keyword">new</span> Node(i);</span><br><span class="line">size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(index &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(index == <span class="number">0</span>) &#123;<span class="comment">// 删除头结点</span></span><br><span class="line">head = head.next;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">Node temp = head;</span><br><span class="line"><span class="keyword">while</span>(temp.next != <span class="keyword">null</span>) &#123;<span class="comment">// 删除指定位置结点</span></span><br><span class="line"><span class="keyword">if</span>(index == i) &#123;</span><br><span class="line">temp.next = temp.next.next;</span><br><span class="line">size--;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">temp = temp.next;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Node temp = head;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size(); ++i) &#123;</span><br><span class="line">System.out.print(temp.data + <span class="string">" "</span>);</span><br><span class="line">temp = temp.next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树实现</title>
      <link href="/2018/06/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0/"/>
      <url>/2018/06/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AE%9E%E7%8E%B0/</url>
      <content type="html"><![CDATA[<h3 id="结点结构"><a href="#结点结构" class="headerlink" title="结点结构"></a>结点结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T data;</span><br><span class="line">    <span class="keyword">public</span> TreeNode&lt;T&gt; left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode&lt;T&gt; right;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(T data, TreeNode&lt;T&gt; left, TreeNode&lt;T&gt; right)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="先序创建二叉树"><a href="#先序创建二叉树" class="headerlink" title="先序创建二叉树"></a>先序创建二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;<span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 先序创建二叉树</span></span><br><span class="line"><span class="comment">     * 返回：根节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode&lt;T&gt;  <span class="title">creatBinaryPre</span><span class="params">(LinkedList&lt;T&gt; treeData)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TreeNode&lt;T&gt; root=<span class="keyword">null</span>;</span><br><span class="line">        T data=treeData.removeFirst();</span><br><span class="line">        <span class="keyword">if</span> (data!=<span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            root=<span class="keyword">new</span> TreeNode&lt;T&gt;(data, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            root.left=creatBinaryPre(treeData);</span><br><span class="line">            root.right=creatBinaryPre(treeData);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="先序遍历二叉树"><a href="#先序遍历二叉树" class="headerlink" title="先序遍历二叉树"></a>先序遍历二叉树</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 先序遍历二叉树（递归）</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">PrintBinaryTreePreRecur</span><span class="params">(TreeNode&lt;T&gt; root)</span></span></span><br><span class="line"><span class="function">   </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (root!=<span class="keyword">null</span>) </span><br><span class="line">       &#123;</span><br><span class="line">           System.out.print(root.data);</span><br><span class="line">           PrintBinaryTreePreRecur(root.left);</span><br><span class="line">           PrintBinaryTreePreRecur(root.right);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java继承类</title>
      <link href="/2018/06/09/Java%E7%BB%A7%E6%89%BF%E7%B1%BB/"/>
      <url>/2018/06/09/Java%E7%BB%A7%E6%89%BF%E7%B1%BB/</url>
      <content type="html"><![CDATA[<h3 id="父类"><a href="#父类" class="headerlink" title="父类"></a>父类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Privilege</span></span>&#123;</span><br><span class="line">String name;</span><br><span class="line">Map&lt;String, Integer&gt; Privileges = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrivileges</span><span class="params">(Map&lt;String, Integer&gt; Privileges)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.Privileges = Privileges;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="子类继承"><a href="#子类继承" class="headerlink" title="子类继承"></a>子类继承</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span> <span class="keyword">extends</span> <span class="title">Privilege</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Role</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子类继承-1"><a href="#子类继承-1" class="headerlink" title="子类继承"></a>子类继承</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">Privilege</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>阿里笔试-着色问题</title>
      <link href="/2018/06/09/%E9%98%BF%E9%87%8C%E7%BC%96%E7%A8%8B%E9%A2%98/"/>
      <url>/2018/06/09/%E9%98%BF%E9%87%8C%E7%BC%96%E7%A8%8B%E9%A2%98/</url>
      <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>将一个圆分为N个扇形，使用M个颜色对这些扇形进行填充，相邻扇形的颜色不能相同，问：有多少种填充方式<br>例如：若N=3，M=3，则有6种方式。<br>样例输入：5 5<br>样例输出：1020</p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>思路：用递归比较好解决。设最终状态为f(n, m), 一共有两种情况到达最终状态：填最后一个扇形时，它的相邻两个扇形颜色一样和不一样。不一样时，可用颜色为m-2，从状态f(n, m-1)到达；一样时，可用颜色m-1,从状态f(n, m-2)到达.<br>递推数列：f(n,m) = (m-2)<em>f(n, m-1) + (m-1)</em>f(n, m-2)<br>初值：f(n, 1) = n;    f(n, 2) = n<em>(n-1);    f(n, 3) = n</em>(n-1)*(n-2)</p><a id="more"></a><h3 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo01</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">2</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m*(m-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">3</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> m*(m-<span class="number">1</span>)*(m-<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (m-<span class="number">2</span>)*f(n-<span class="number">1</span>, m) + (m-<span class="number">1</span>)*f(n-<span class="number">2</span>, m);<span class="comment">//f(n, m) = (m-2)*f(n-1, m) + (m-2)*f(n-2, m)</span></span><br><span class="line">&#125;<span class="comment">//n-1个扇形时，相邻的两个扇形颜色必定不同，因此是m-2</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;<span class="comment">//n-2个扇形时，相邻的两个扇形颜色可以不同，因此是m-1</span></span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="keyword">int</span> n = sc.nextInt();<span class="comment">// 扇形个数</span></span><br><span class="line"><span class="keyword">int</span> m = sc.nextInt();<span class="comment">// 颜色数目</span></span><br><span class="line">sc.close();</span><br><span class="line"><span class="keyword">int</span> num = f(n, m);</span><br><span class="line">System.out.println(num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>回溯法思想</title>
      <link href="/2018/06/09/%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%80%9D%E6%83%B3/"/>
      <url>/2018/06/09/%E5%9B%9E%E6%BA%AF%E6%B3%95%E6%80%9D%E6%83%B3/</url>
      <content type="html"><![CDATA[<h3 id="子集树与排列树"><a href="#子集树与排列树" class="headerlink" title="子集树与排列树"></a>子集树与排列树</h3><p>当所给问题是从n个元素的集合S中找出满足某种性质的子集时，解空间为子集树。<br>例如：0-1背包问题 (选或不选问题)<br>当所给问题是从n个元素的集合S中找出满足某种性质的排列时，解空间为排列树。<br>例如：旅行售货员问题（选择顺序问题）</p><h3 id="算法结构"><a href="#算法结构" class="headerlink" title="算法结构"></a>算法结构</h3><p><img src="http://img0.ph.126.net/Melu_I5gINJZ_h1Y3Wj8NA==/6631466888424244590.png" alt=""></p><a id="more"></a><h3 id="深度优先搜索与广度优先搜索算法有何区别"><a href="#深度优先搜索与广度优先搜索算法有何区别" class="headerlink" title="深度优先搜索与广度优先搜索算法有何区别"></a>深度优先搜索与广度优先搜索算法有何区别</h3><p>深度优先搜索法不全部保留结点，扩展完的结点从数据存储结构栈中弹出删去，在栈中存储的结点数就是解空间树的深度，因此它占用空间较少。所以，<font color="red">当搜索树的结点较多，用其它方法易产生内存溢出时，深度优先搜索不失为一种有效的求解方法。</font><br>广度优先搜索算法，一般需存储产生所有结点，占用的存储空间要比深度优先搜索大得多，因此，程序设计中，必须考虑溢出和节省内存空间的问题。<font color="red"></font>但广度优先搜索法一般无回溯操作（即入栈和出栈的操作），所以运行速度比深度优先搜索要快些。</p><h3 id="回溯与分支限界区别"><a href="#回溯与分支限界区别" class="headerlink" title="回溯与分支限界区别"></a>回溯与分支限界区别</h3><p>回溯法以深度优先的方式搜索解空间树T，而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树T。它们在问题的解空间树T上搜索的方法不同，适合解决的问题也就不同。一般情况下，回溯法的求解目标是找出T中满足约束条件的所有解的方案，而分支限界法的求解目标则是找出满足约束条件的一个解，或是在满足约束条件的解中找出使某一目标函数值达到极大或极小的解，即在某种意义下的最优解。相对而言，分支限界算法的解空间比回溯法大得多，因此当内存容量有限时，回溯法成功的可能性更大。</p><h3 id="最优化处理问题"><a href="#最优化处理问题" class="headerlink" title="最优化处理问题"></a>最优化处理问题</h3><p>在处理最优问题时，采用穷举法、回溯法或分支限界法都可以通过利用当前最优解和上界函数加速。仅就对限界剪支的效率而言，优先队列的分支限界法显然要更充分一些。在穷举法中通过上界函数与当前情况下函数值的比较可以直接略过不合要求的情况而省去了更进一步的枚举和判断；回溯法则因为层次的划分，可以在上界函数值小于当前最优解时，剪去以该结点为根的子树，也就是节省了搜索范围；分支限界法在这方面除了可以做到回溯法能做到的之外，同时若采用优先队列的分支限界法，用上界函数作为活结点的优先级，一旦有叶结点成为当前扩展结点，就意味着该叶结点所对应的解即为最优解，可以立即终止其余的过程。在前面的例题中曾说明，优先队列的分支限界法更象是有选择、有目的地进行搜索，时间效率、空间效率都是比较高的。</p><h3 id="算法总结"><a href="#算法总结" class="headerlink" title="算法总结"></a>算法总结</h3><p>一个问题是该用递推、贪心、搜索还是动态规划，完全是由这个问题本身阶段间状态的转移方式决定的！<br>每个阶段只有一个状态-&gt;递推；<br>每个阶段的最优状态都是由上一个阶段的最优状态得到的-&gt;贪心；<br>每个阶段的最优状态是由之前所有阶段的状态的组合得到的-&gt;搜索；<br>每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到而不管之前这个状态是如何得到的-&gt;动态规划。</p><h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>1.求最优解问题<br>2.整体问题的最优解依赖于各个子问题的最优解<br>3.把大问题分解成小问题，小问题之间还有相互重叠的更小的子问题<br>4.从上往下分析，从下往上求解，避免重复求解小问题</p>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最长公共子串-最长公共子序列</title>
      <link href="/2018/06/09/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2018/06/09/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2-%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<h3 id="最长公共子串"><a href="#最长公共子串" class="headerlink" title="最长公共子串"></a>最长公共子串</h3><p><img src="http://img1.ph.126.net/H1EyGXbRxcDOMDSbA3Yztw==/6632750018491298641.png" alt=""></p><h3 id="DP实现"><a href="#DP实现" class="headerlink" title="DP实现"></a>DP实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubStr</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> len1 = str1.length();</span><br><span class="line"><span class="keyword">int</span> len2 = str2.length();</span><br><span class="line"><span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span> [len1][len2];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;<span class="comment">// 状态转移</span></span><br><span class="line"><span class="keyword">if</span>(dp[i][j] &gt; result) &#123;</span><br><span class="line">result = dp[i][j];</span><br><span class="line">index = i;<span class="comment">// 记录最大子串的最后一个下标</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//result = result &gt; dp[i][j] ? result : dp[i][j];</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = <span class="number">1</span>;</span><br><span class="line">result = result &gt; dp[i][j] ? result : dp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(result);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = index - result + <span class="number">1</span>; i &lt;= index; i++) &#123;</span><br><span class="line">System.out.print(str1.charAt(i) + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="最长公共子序列"><a href="#最长公共子序列" class="headerlink" title="最长公共子序列"></a>最长公共子序列</h3><p>####动态规划<br>假设Z=&lt;z1,z2,⋯,zk&gt;是X与Y的LCS， 我们观察到<br>如果Xm=Yn，则Zk=Xm=Yn，有Zk−1是Xm−1与Yn−1的LCS；<br>如果Xm≠Yn，则Zk是Xm与Yn−1的LCS，或者是Xm−1与Yn的LCS。<br>因此，求解LCS的问题则变成递归求解的两个子问题。但是，上述的递归求解的办法中，重复的子问题多，效率低下。改进的办法——用空间换时间，用数组保存中间状态，方便后面的计算。这就是动态规划（DP)的核心思想了。<br>DP求解LCS<br>用二维数组c[i][j]记录串x1x2⋯xi与y1y2⋯yj的LCS长度，则可得到状态转移方程:<br><img src="http://img0.ph.126.net/-Sm5fciB32vVAG5sXvUx0g==/6632732426305233528.png" alt=""></p><h3 id="DP实现-1"><a href="#DP实现-1" class="headerlink" title="DP实现"></a>DP实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">maxSubSequence</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> len1 = str1.length();</span><br><span class="line"><span class="keyword">int</span> len2 = str2.length();</span><br><span class="line"><span class="keyword">int</span> [][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len1][len2];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len1; ++i) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len2; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; j &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">dp[i][j] = dp[i-<span class="number">1</span>][j] &gt; dp[i][j-<span class="number">1</span>] ? dp[i-<span class="number">1</span>][j] : dp[i][j-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(str1.charAt(i) == str2.charAt(j)) &#123;</span><br><span class="line">dp[i][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(dp[len1 - <span class="number">1</span>][len2 - <span class="number">1</span>]);</span><br><span class="line"><span class="keyword">return</span> dp[len1-<span class="number">1</span>][len2-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>分糖果</title>
      <link href="/2018/06/09/%E5%88%86%E7%B3%96%E6%9E%9C/"/>
      <url>/2018/06/09/%E5%88%86%E7%B3%96%E6%9E%9C/</url>
      <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><ul><li>分糖果：科大讯飞第二道编程题</li><li>小明和小红是好朋友，但最近遇到一个棘手的问题，有一盒糖果要分成两份但是每颗糖果质量都不尽相同，</li><li>但为了分配的公平每份糖的糖果数量相差不得超过1，在此条件下两份糖果的质量差距尽可能小。</li><li>输入一行数，包含一个数n，代表糖果数量，后面一次是n个整数一次表示每个糖果的质量，每个糖果的质量都是1到450</li><li>之间的一个整数，每盒最多有20个糖果。</li><li>输出：每个样例输出两个数字分别为两堆糖果的质量，如不相同，先小后大。</li><li>样例：输入：5 9 6 5 8 7</li><li>输出：17 18</li></ul><a id="more"></a><h3 id="算法思想"><a href="#算法思想" class="headerlink" title="算法思想"></a>算法思想</h3><p>回溯，在数量差值为1的结果中找出最小的质量差</p><h3 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">divide</span><span class="params">(candies, num, select, sum, total, index)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> min</span><br><span class="line">    <span class="keyword">global</span> res</span><br><span class="line">    <span class="keyword">if</span>(abs(total-sum*<span class="number">2</span>) &lt; min):</span><br><span class="line">        res = sum</span><br><span class="line">        min = abs(total-sum*<span class="number">2</span>)</span><br><span class="line">        result.append(select)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(candies)):</span><br><span class="line">        <span class="keyword">if</span>(index == num<span class="number">-1</span>): return3</span><br><span class="line">        select.append(candies[index])</span><br><span class="line">        sum += candies[index]</span><br><span class="line">        temp = select.copy()</span><br><span class="line">        <span class="keyword">if</span>(len(select) &lt;= int(num/<span class="number">2</span>)+<span class="number">1</span>):</span><br><span class="line">            index += <span class="number">1</span></span><br><span class="line">            divide(candies, num, temp, sum, total, index)</span><br><span class="line">        sum -= select[len(select) - <span class="number">1</span>]</span><br><span class="line">        select.remove(select[len(select)<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 面试 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 回溯 </tag>
            
            <tag> 面试题 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>括号生成</title>
      <link href="/2018/06/09/DFS-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
      <url>/2018/06/09/DFS-%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给出 n 代表生成括号的对数，请你写出一个函数，使其能够生成所有可能的并且有效的括号组合。<br>例如，给出 n = 3，生成结果为：<br>[<br>  “((()))”,<br>  “(()())”,<br>  “(())()”,<br>  “()(())”,<br>  “()()()”<br>]</p><a id="more"></a><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><h3 id="回溯实现"><a href="#回溯实现" class="headerlink" title="回溯实现"></a>回溯实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;String&gt; result, String str, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; n || right &gt; n || left &lt; right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(left == n &amp;&amp; right == n)&#123;</span><br><span class="line">            result.add(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dfs(result, str+<span class="string">"("</span>, left+<span class="number">1</span>, right, n);</span><br><span class="line">        dfs(result, str+<span class="string">")"</span>, left, right+<span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        List&lt;String&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        dfs(result, str, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP-乘积最大子序列</title>
      <link href="/2018/06/09/DP-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/"/>
      <url>/2018/06/09/DP-%E4%B9%98%E7%A7%AF%E6%9C%80%E5%A4%A7%E5%AD%90%E5%BA%8F%E5%88%97/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个整数数组 nums ，找出一个序列中乘积最大的连续子序列（该序列至少包含一个数）。<br>示例 1:<br>输入: [2,3,-2,4]<br>输出: 6<br>解释: 子数组 [2,3] 有最大乘积 6。</p><p>示例 2:<br>输入: [-2,0,-1]<br>输出: 0<br>解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。<br><a id="more"></a></p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>本题是求最大乘积，是最大子段和的变种。最大乘积可以由正数<em>正数和负数</em>负数得到，因此，需要同时记录下最大值和最小值。<br>状态转移方程：<br>dp[i] = max(max,dp[i-1])<br>max = max(max<em>num[i],min</em>num[i],nums[i])<br>min = min(max<em>num[i],min</em>num[i],nums[i])<br>其中，dp[i]表示前i个数中的最大乘积，maxm表示以第i-1个字符结尾的最大乘积,minm表示以第i-1个字符结尾的最小乘积,nums[i]即为第i个数。</p><h3 id="DP实现"><a href="#DP实现" class="headerlink" title="DP实现"></a>DP实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProduct</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</span><br><span class="line">        dp[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> max = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> min = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                max = Math.max(nums[i], max*nums[i]);</span><br><span class="line">                min = Math.min(nums[i], min*nums[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = max;</span><br><span class="line">                max = Math.max(nums[i], min*nums[i]);</span><br><span class="line">                min = Math.min(nums[i], temp*nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i] = Math.max(max, dp[i-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP-最大上升子序列LIS</title>
      <link href="/2018/06/09/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97LIS/"/>
      <url>/2018/06/09/%E6%9C%80%E5%A4%A7%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97LIS/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。<br>示例:<br>输入: [10,9,2,5,3,7,101,18]<br>输出: 4<br>解释: 最长的上升子序列是 [2,3,7,101]，它的长度是 4。<br>说明:<br>可能会有多种最长上升子序列的组合，你只需要输出对应的长度即可。<br>你算法的时间复杂度应该为 O(n2) 。<br>进阶: 你能将算法的时间复杂度降低到 O(n log n) 吗?</p><a id="more"></a><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><h3 id="O-n-2-解法，DP实现"><a href="#O-n-2-解法，DP实现" class="headerlink" title="O(n^2)解法，DP实现"></a>O(n^2)解法，DP实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isP</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(j)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> i++; j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;String&gt;&gt; result, String s, List&lt;String&gt; res, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == s.length())&#123;  </span><br><span class="line">            List&lt;String&gt; ress = <span class="keyword">new</span> ArrayList&lt;String&gt;(res);  </span><br><span class="line">            result.add(ress);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isP(s.substring(index, i+<span class="number">1</span>)))&#123;</span><br><span class="line">                res.add(s.substring(index, i+<span class="number">1</span>));</span><br><span class="line">                dfs(result, s, res, i+<span class="number">1</span>);</span><br><span class="line">                res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        dfs(result, s, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP-最长递增子序列的个数</title>
      <link href="/2018/06/09/DP-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0/"/>
      <url>/2018/06/09/DP-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个未排序的整数数组，找到最长递增子序列的个数。<br>示例 1:<br>输入: [1,3,5,4,7]<br>输出: 2<br>解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。</p><p>示例 2:<br>输入: [2,2,2,2,2]<br>输出: 5<br>解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。</p><p>注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。</p><a id="more"></a><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><h3 id="O-n-2-解法，DP实现"><a href="#O-n-2-解法，DP实现" class="headerlink" title="O(n^2)解法，DP实现"></a>O(n^2)解法，DP实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cclass Solution &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findNumberOfLIS</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> [] dp = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</span><br><span class="line">        <span class="keyword">int</span> [] count = <span class="keyword">new</span> <span class="keyword">int</span> [nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            dp[i] = count[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[i] &lt; dp[j] + <span class="number">1</span>)&#123;</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                        count[i] = count[j];</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[i] == dp[j] + <span class="number">1</span>)&#123;   <span class="comment">//统计当前长度子序列可由多少次长序列加1得到</span></span><br><span class="line">                        count[i] += count[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            maxLen = Math.max(maxLen, dp[i]);</span><br><span class="line">            <span class="comment">// System.out.println(count[i] + " " + dp[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count.length; i++)&#123;  <span class="comment">// 考虑重复情况</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] == maxLen) res += count[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count[nums.length-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>回溯-分割回文串</title>
      <link href="/2018/06/09/%E5%9B%9E%E6%BA%AF-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
      <url>/2018/06/09/%E5%9B%9E%E6%BA%AF-%E5%88%86%E5%89%B2%E5%9B%9E%E6%96%87%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s，将 s 分割成一些子串，使每个子串都是回文串。<br>返回 s 所有可能的分割方案。<br>示例:<br>输入: “aab”<br>输出:<br>[<br>  [“aa”,”b”],<br>  [“a”,”a”,”b”]<br>]</p><a id="more"></a><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><h3 id="回溯实现"><a href="#回溯实现" class="headerlink" title="回溯实现"></a>回溯实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isP</span><span class="params">(String s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = s.length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) != s.charAt(j)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> i++; j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(List&lt;List&lt;String&gt;&gt; result, String s, List&lt;String&gt; res, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index == s.length())&#123;  </span><br><span class="line">            List&lt;String&gt; ress = <span class="keyword">new</span> ArrayList&lt;String&gt;(res);  </span><br><span class="line">            result.add(ress);  </span><br><span class="line">            <span class="keyword">return</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isP(s.substring(index, i+<span class="number">1</span>)))&#123;</span><br><span class="line">                res.add(s.substring(index, i+<span class="number">1</span>));</span><br><span class="line">                dfs(result, s, res, i+<span class="number">1</span>);</span><br><span class="line">                res.remove(res.size()-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; result = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        List&lt;String&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        dfs(result, s, res, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP+回溯-单词拆分 II</title>
      <link href="/2018/06/09/DP+%E5%9B%9E%E6%BA%AF-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20II/"/>
      <url>/2018/06/09/DP+%E5%9B%9E%E6%BA%AF-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20II/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。<br>说明：<br>分隔时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：<br>输入:<br>s = “catsanddog”<br>wordDict = [“cat”, “cats”, “and”, “sand”, “dog”]<br>输出:<br>[<br>  “cats and dog”,<br>  “cat sand dog”<br>]</p><p>示例 2：<br>输入:<br>s = “pineapplepenapple”<br>wordDict = [“apple”, “pen”, “applepen”, “pine”, “pineapple”]<br>输出:<br>[<br>  “pine apple pen apple”,<br>  “pineapple pen apple”,<br>  “pine applepen apple”<br>]<br>解释: 注意你可以重复使用字典中的单词。</p><p>示例 3：<br>输入:<br>s = “catsandog”<br>wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出:<br>[]<br><a id="more"></a></p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>这道题类似  Word Break I 判断是否能把字符串拆分为字典里的单词 @LeetCode 只不过要求计算的并不仅仅是是否能拆分，而是要求出所有的拆分方案。因此用递归。<br>但是直接递归做会超时，原因是LeetCode里有几个很长但是无法拆分的情况，所以就先跑一遍Word Break I，先判断能否拆分，然后再进行拆分。</p><h3 id="DP实现"><a href="#DP实现" class="headerlink" title="DP实现"></a>DP实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">boolean</span>[] canBreak = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>];  </span><br><span class="line">        canBreak[<span class="number">0</span>] = <span class="keyword">true</span>;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=s.length(); i++) &#123;  </span><br><span class="line">            <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;  </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;  </span><br><span class="line">                <span class="keyword">if</span>(canBreak[j] &amp;&amp; wordDict.contains(s.substring(j,i))) &#123;  </span><br><span class="line">                    flag = <span class="keyword">true</span>;  </span><br><span class="line">                    <span class="keyword">break</span>;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">            canBreak[i] = flag;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> canBreak[s.length()];  </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String s, List&lt;String&gt; wordDict, String str, <span class="keyword">int</span> index)</span></span>&#123;</span><br><span class="line">        String result = str;            <span class="comment">//记录字符串状态</span></span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        String tmp = s.substring(index, len);</span><br><span class="line">        <span class="keyword">if</span>(wordDict.contains(tmp))&#123;     <span class="comment">//最后一段存在于字典中，则保存结果</span></span><br><span class="line">            str += tmp;</span><br><span class="line">            res.add(str);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; listIndex = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        List&lt;String&gt; listStr = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; len; i++)&#123;</span><br><span class="line">            String temp = s.substring(index, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(wordDict.contains(temp))&#123;</span><br><span class="line">                listIndex.add(i+<span class="number">1</span>);</span><br><span class="line">                listStr.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String temp = result;   <span class="comment">//保存递归前的字符串状态，以便回溯</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; listIndex.size(); i++)&#123;</span><br><span class="line">            result += listStr.get(i) + <span class="string">" "</span>;</span><br><span class="line">            dfs(s, wordDict, result, listIndex.get(i));</span><br><span class="line">            result = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!isBreak(s, wordDict)) <span class="keyword">return</span> res;</span><br><span class="line">        String str = <span class="string">""</span>;</span><br><span class="line">        dfs(s, wordDict, str, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 回溯 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP-单词拆分 I</title>
      <link href="/2018/06/09/DP-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20I/"/>
      <url>/2018/06/09/DP-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%20I/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。<br>说明：<br>拆分时可以重复使用字典中的单词。<br>你可以假设字典中没有重复的单词。<br>示例 1：<br>输入: s = “leetcode”, wordDict = [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以被拆分成 “leet code”。</p><p>示例 2：<br>输入: s = “applepenapple”, wordDict = [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以被拆分成 “apple pen apple”。<br>     注意你可以重复使用字典中的单词。</p><p>示例 3：<br>输入: s = “catsandog”, wordDict = [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false<br><a id="more"></a></p><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><p>动态规划的思路：<br>将问题拆分成更小的子问题。用dp[i]表示0到i的子字符串是否可以拆分成满足条件的单词，在计算dp[i]的时候，我们已经知道dp[0],dp[1],…,dp[i-1],如果以i为结尾的j~i子串是满足条件的，并且0~j的子串也是在字典中的，那么dp[i]就是true。<br>用公式表示就是：</p><p><center><font color="red" size="5" align="center">dp[j]&amp;&amp;s.substring[j,i+1]∈dict</font></center></p><h3 id="DP实现"><a href="#DP实现" class="headerlink" title="DP实现"></a>DP实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;;</span><br><span class="line">        <span class="keyword">boolean</span> [] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[s.length()+<span class="number">1</span>]；</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[j] &amp;&amp; wordDict.contains(s.substring(j, i+<span class="number">1</span>)))&#123;</span><br><span class="line">                    dp[i+<span class="number">1</span>] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s.length()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DFS解法，超时"><a href="#DFS解法，超时" class="headerlink" title="DFS解法，超时"></a>DFS解法，超时</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(String s, List&lt;String&gt; wordDict, <span class="keyword">int</span> index)</span></span>&#123; <span class="comment">// 超时</span></span><br><span class="line">        String left = s.substring(index, s.length());</span><br><span class="line">        <span class="keyword">if</span>(wordDict.contains(left))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; s.length(); i++)&#123;</span><br><span class="line">            String temp = s.substring(index, i+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(wordDict.contains(temp))&#123;</span><br><span class="line">                list.add(i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Integer each:list) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dfs(s, wordDict, each))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dfs(s, wordDict, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>DP-最长回文子串</title>
      <link href="/2018/06/09/DP-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"/>
      <url>/2018/06/09/DP-%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/</url>
      <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为1000。<br>示例 1：<br>输入: “babad”<br>输出: “bab”<br>注意: “aba”也是一个有效答案。</p><p>示例 2：<br>输入: “cbbd”<br>输出: “bb”</p><a id="more"></a><h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><h3 id="逆向DP"><a href="#逆向DP" class="headerlink" title="逆向DP"></a>逆向DP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.length();</span><br><span class="line">        <span class="keyword">boolean</span> [][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span> [len+<span class="number">1</span>][len+<span class="number">1</span>];</span><br><span class="line">        String longStr = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            dp[i][i] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; (j-i&lt;=<span class="number">1</span> || dp[i+<span class="number">1</span>][j-<span class="number">1</span>]))&#123;</span><br><span class="line">                    dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span>(longStr.length() &lt; s.substring(i, j+<span class="number">1</span>).length())&#123;</span><br><span class="line">                        longStr = s.substring(i, j+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> longStr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正向DP"><a href="#正向DP" class="headerlink" title="正向DP"></a>正向DP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> len = s.length();</span><br><span class="line">       <span class="keyword">boolean</span> [][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span> [len+<span class="number">1</span>][len+<span class="number">1</span>];</span><br><span class="line">       String longStr = <span class="string">""</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= len; i++)&#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;= <span class="number">1</span>; j--)&#123;</span><br><span class="line">               <span class="keyword">if</span>(s.charAt(i-<span class="number">1</span>) == s.charAt(j-<span class="number">1</span>) &amp;&amp; (i-j&lt;=<span class="number">1</span> || dp[i-<span class="number">1</span>][j+<span class="number">1</span>]))&#123;</span><br><span class="line">                   dp[i][j] = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">if</span>(longStr.length() &lt; s.substring(j-<span class="number">1</span>, i).length())&#123;</span><br><span class="line">                       longStr = s.substring(j-<span class="number">1</span>, i);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> longStr;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/06/08/hello-world/"/>
      <url>/2018/06/08/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
